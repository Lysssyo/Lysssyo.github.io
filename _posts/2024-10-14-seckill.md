---
title: 秒杀业务
date: 2024-10-14 12:55:00 +0800
categories: [中间件, Redis]
tags: [Redis,秒杀,乐观锁]
---



## 1. 业务介绍

用户可以在用户端参与优惠券秒杀。用户下单以后，后端要在数据库对优惠券的库存 -1 并且创建用户购买优惠券的订单。

## 2. 主要问题

- 全局唯一Id

- 超卖
- 一人一单

## 3. 解决全局唯一Id问题

**全局ID生成器**，是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：

- 唯一性
- 高可用
- 高性能
- 递增性
- 安全性

```java

```

## 4. 解决超卖问题

原始的秒杀流程：

<img src="assets/2024-10-14-seckill.assets/image-20241014154848898.png" alt="image-20241014154848898" style="zoom: 60%;" />

考虑库存仅剩1个的情况：假设线程1过来查询库存，判断出来库存为1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也为1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。

超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是**加锁**：而对于加锁，我们通常有两种解决方案

- 悲观锁

  认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。例如Synchronized、Lock都属于悲观锁

- 乐观锁

  认为线程安全问题不一定会发生，因此不加锁，只是在**更新数据时**去判断有没有其它线程对数据做了修改。如果没有修改则认为是安全的，自己才更新数据。如果已经被其它线程修改说明发生了安全问题，此时可以重试或异常。

**在这里，采用乐观锁解决超卖问题：**

<img src="assets/2024-10-14-seckill.assets/image-20241014155226735.png" alt="image-20241014155226735" style="zoom:80%;" />

也可以将`stock`和`version`合二为一，以库存`stock`自身作为`version`：

<img src="assets/2024-10-14-seckill.assets/image-20241014155326761.png" alt="image-20241014155326761" style="zoom:80%;" />

**具体分析图二：**

在高并发下，假设线程1，线程2，线程3同时进入数据库得到优惠券的库存`stock`。三个线程都判断得到stock大于0准备更新数据库，但是，当线程1更新数据库后，stock-1，此时线程2还想更新数据库就不满足sql中的where判断`stock = #{stock}`。即解决了线程安全问题。

**但是，在这里，乐观锁不是一个明智的选择，这里尽是为了介绍乐观锁的原理才这样设计流程的。**实际上，sql的where条件应该是`where id =#{id} and stock > 0`。原因如下：如果sql的where条件是`where id = #{id} and stock = #{stock}`，假设3个线程设为A，B，C在0.00ms时刻查询数据库得到库存，如果用乐观锁，那么势必会有两个线程买不到优惠券。但在0.10ms时刻又进入一个线程设为D，它就可以买到优惠券，这显然是不公平的。

综上：解决超卖问题的关键在于优化SQL的WHERE条件。

代码如下：

```java
@Override
@Transactional
public Result seckillVoucher(Long voucherId) {
    // 1.查询优惠券
    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
    // 2.判断秒杀是否开始
    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
        // 尚未开始
        throw new HeimaDpException(CommonException.SEC_KILL_NOT_BEGIN.getErrMessage());
    }
    // 3.判断秒杀是否已经结束
    if (voucher.getEndTime().isBefore(LocalDateTime.now())) {
        // 尚未开始
        throw new HeimaDpException(CommonException.SEC_KILL_HAS_BEEN_ENDED.getErrMessage());
    }
    // 4.判断库存是否充足
    if (voucher.getStock() < 1) {
        // 库存不足
        throw new HeimaDpException(CommonException.SOCK_NOT_ENOUGH.getErrMessage());
    }
    
    //5，扣减库存
    boolean success = seckillVoucherService.update()
        .setSql("stock = stock - 1") // set stock = stock - 1
        .eq("voucher_id", voucherId).gt("stock", 0) // where id = ? and stock > 0
        .update();
    
    if (!success) {
        //扣减库存
        throw new HeimaDpException(CommonException.SOCK_NOT_ENOUGH.getErrMessage());
    }
    
    //6.创建订单
    VoucherOrder voucherOrder = new VoucherOrder();
    // 6.1.订单id
    long orderId = redisIdWorker.nextId("order");
    voucherOrder.setId(orderId);
    // 6.2.用户id
    Long userId = UserHolder.getUser().getId();
    voucherOrder.setUserId(userId);
    // 6.3.代金券id
    voucherOrder.setVoucherId(voucherId);
    save(voucherOrder);

    return Result.ok(orderId);
}
```

## 5. 一人一单

解决超卖问题后，接下来解决一人一单问题。

<img src="assets/2024-10-14-seckill.assets/image-20241014162020864.png" alt="image-20241014162020864" style="zoom:70%;" />

注意到，这里也有线程安全问题：假设线程A线程B同时要为userId为10的用户购买id为4的优惠券，当这两个线程都判断到订单不存在的时候，都进行扣库存，创建订单的操作，那么userId为10的用户就下了两单。

这里，**采用悲观锁**解决一人一单问题。**因为不是修改操作，所以没法使用乐观锁。**















