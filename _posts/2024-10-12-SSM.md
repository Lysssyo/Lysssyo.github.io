---
title: SSM
date: 2024-09-20 00:31:00 +0800
categories: [Java,JavaWeb]
tags: [SSM]
---

## 1. Spring

### 1.1 Spring简介

​		IBM(IT公司-国际商业机器公司)在1997年提出了EJB思想，早期的JAVAEE开发大都基于该思想。Rod Johnson(Java和J2EE开发领域的专家)在2002年出版的`Expert One-on-One J2EE Design and Development`,书中有阐述在开发中使用EJB该如何做JAVAEE的开发。Rod Johnson在2004年出版的`Expert One-on-One J2EE Development without EJB`,书中提出了比EJB思想更高效的实现方案，并且在同年将方案进行了具体的落地实现，这个实现就是Spring1.0。

​		随着时间推移，版本不断更新维护，目前最新的是Spring5

> * Spring1.0是**纯配置文件**开发
> * Spring2.0为了简化开发引入了**注解开发**，此时是配置文件加注解的开发方式
> * **Spring3.0已经可以进行纯注解开发**，使开发效率大幅提升，我们的课程会以注解开发为主
> * Spring4.0根据JDK的版本升级对个别API进行了调整
> * Spring5.0已经全面支持JDK8，现在Spring最新的是5系列所以建议大家把JDK安装成1.8版

### 1.2 Spring系统架构

​		Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基。而Spring Framework的发展也经历了很多版本的变更，每个版本都有相应的调整。

​		以下是Spring 4.0的架构图：

![image-20240525154820759](/assets/SSM.assets/image-20240525154820759.png)

- 核心层

  * Core Container：核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块


- AOP层

  * AOP：面向切面编程，它依赖核心层容器，目的是==在不改变原有代码的前提下对其进行功能增强==

  * Aspects：AOP是思想，Aspects是对AOP思想的具体实现


- 数据层

  * Data Access：数据访问，Spring全家桶中有对数据访问的具体实现技术

  * Data Integration：**数据集成**，Spring支持**整合其他的数据层解决方案**，比如Mybatis

  * Transactions：事务，Spring中事务管理是Spring AOP的一个具体实现


- Web层

  * Spring MVC


- Test层

  * Spring主要整合了Junit来完成单元测试和集成测试

### 1.3 IOC & DI 初识

#### 1.3.1 IOC & DI 简介

1. IOC（Inversion of Control）控制反转

   - 什么是控制反转呢？

     使用对象时，由主动new产生对象转换为由==外部==提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。

   - Spring和IOC之间的关系是什么呢?

     Spring技术**对IOC思想进行了实现**，Spring提供了一个容器，称为==IOC容器==，用来充当IOC思想中的"外部"

   - IOC容器的作用以及内部存放的是什么?

​		IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类的对象。被创建或被管理的对象在IOC容器中统称为Bean



2. DI（Dependency Injection）依赖注入

   ![1629735078619](/assets/SSM.assets/1629735078619.png)

   - 什么是依赖注入呢?

     在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入。

     >  业务层要用数据层的类对象，以前是自己`new`的，现在自己不new了，靠`别人[外部其实指的就是IOC容器]`来给注入进来，这种思想就是依赖注入

   - IOC容器中哪些bean之间要建立依赖关系呢?

     ​	这个需要程序员根据业务需求提前建立好关系，如业务层需要依赖数据层，service就要和dao建立依赖关系

#### 1.3.2 IOC基础Demo——基于配置文件

1. 导入坐标

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.2.10.RELEASE</version>
    </dependency>
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.12</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

2. 创建Spring配置文件，完成Spring基础配置

```xml
<!--applicationContext.xml-->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

</beans>
```

3. 创建需要被IOC容器管理的类

```java
public interface UserService {
    void login();
}

public class UserServiceImpl implements UserService {
    public void login() {
        System.out.println("User login");
    }
}
```

4. Spring配置文件完成Bean的配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="userService" class="com.lysssyo.service.Impl.UserServiceImpl"/>

</beans>
```

5. 编码

```java
public class SpringDemo {
    public static void main(String[] args) {
        // 加载配置文件得到上下文对象，也就是容器对象
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        UserService userService = (UserService) ctx.getBean("userService");
        userService.login();
    }
}
```

6. 运行，控制台打印`User login`，运行成功



#### 1.3.3 DI基础Demo——基于配置文件

​		在IOC基础Demo的基础上，添加UserController并添加到IOC容器中

```java
public class UserController {
    private UserService userService=new UserServiceImpl();
    
    public void login(){
        userService.login();
    }
}
```

​		运行类调用UserController的login方法

```java
public class SpringDemo {
    public static void main(String[] args) {
        // 加载配置文件得到上下文对象，也就是容器对象
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        UserController userController = (UserController) ctx.getBean("userController");
        userController.login();
    }
}
```

​		程序可以正常运行，但是，如果UserService的实现类发送变化，那就要重写UserController了，发生变更后，都需要进行编译打包和重部署。这时候，就要用到DI自动注入：

1. 删除UserController的new，为UserController中的成员变量userService提供set方法

```java
public class UserController {
    private UserService userService;

    public void setUserService(UserService userService) {
        this.userService = userService;
    }

    public void login(){
        userService.login();
    }

}
```

2. 修改application.xml

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="userService" class="com.lysssyo.service.Impl.UserServiceImpl"/>
    <bean id="userController" class="com.lysssyo.controller.UserController">
        <property name="userService" ref="userService"/>
    </bean>

</beans>
```

> * name="userService"中`userService`的作用是让Spring的IOC容器在获取到name后，将首字母大写，为IOC容器中的id为userController的Bean对象找setUserService方法，为注入做准备
> * ref="userService"中`userService`的作用是让Spring能在IOC容器中找到id为`userService`的Bean对象给`userController`进行注入



### 1.4 Bean

#### 1.4.1 基础配置

![image-20240525173907159](/assets/SSM.assets/image-20240525173907159.png)



#### 1.4.2 Bean实例化



#### 1.4.3 Bean生命周期







#### 1.4.4 管理第三方Bean

Demo——管理Druid数据源

1. 导入Druid坐标

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.16</version>
</dependency>
```

2. application.xml添加`DruidDataSource`的配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd">
	<!--管理DruidDataSource对象-->
    <<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
 	   	<property name="driverClassName" value="com.mysql.jdbc.Driver"/>
   	 	<property name="url" value="jdbc:mysql://localhost:3306/spring_db"/>
   		<property name="username" value="root"/>
  	    <property name="password" value="123456"/>
	</bean>
</beans>
```

3. 容器中获取Bean对象

```java
public class App {
    public static void main(String[] args) {
       ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
       DataSource dataSource = (DataSource) ctx.getBean("dataSource");
       System.out.println(dataSource);
    }
}
```

**属性优化**

​		Druid数据源中都使用到了一些固定的常量如数据库连接四要素，把这些值写在Spring的配置文件中不利于后期维护。可以将数据库连接四要素提取到properties配置文件，spring来加载配置信息并使用这些信息来完成属性注入。

1. resources下创建一个jdbc.properties文件,并添加对应的属性键值对

```properties
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://127.0.0.1:3306/spring_db
jdbc.username=root
jdbc.password=root
```

2. 在applicationContext.xml中开`context`命名空间

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd">
</beans>
```

3. 加载properties配置文件

​		在配置文件中使用`context`命名空间下的标签来加载properties配置文件

```xml
<context:property-placeholder location="jdbc.properties"/>
```

4. 完成属性注入

​		使用`${key}`来读取properties配置文件中的内容并完成属性注入

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       <!--开启context命名空间-->
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd">
    <!--加载properties配置文件-->
    <context:property-placeholder location="jdbc.properties"/>
    <!--使用 ${key} 来读取properties配置文件中的内容并完成属性注入-->
    <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
        <property name="driverClassName" value="${jdbc.driver}"/>
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
</beans>
```



### 1.5 DI 详解



### 1.6 核心容器

#### 1.6.1 核心容器的创建方式

```java
ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
```

​		读取类路径下的applicationContext.xml创建核心容器



#### 1.6.2 核心容器获取Bean对象

方式一——按名称注入：

```java
UserController userController = (UserController) ctx.getBean("userController");
```

​		这种方式存在的问题是每次获取的时候都需要进行类型转	

方式二——按名称和类型注入：

```
UserController userController = ctx.getBean("userController",UserController.class);
```

方式三——按类型注入：

```
UserController userController = ctx.getBean(UserController.class);
```

​		需要保证IOC容器中这个类型的Bean对象只有一个，如果有两个会报错

![image-20240525172640244](/assets/SSM.assets/image-20240525172640244.png)



#### 1.6.3 容器类层次结构

![image-20240525173155761](/assets/SSM.assets/image-20240525173155761.png)

​		从图中可以看出，容器类也是从无到有根据需要一层层叠加上来的。`BeanFactory`为容器类的顶层接口，`ApplicationContext`为常用接口，`ClassPathXmlApplicationContext`为常用实现类。



#### 1.6.4 顶层接口BeanFactory

​		使用BeanFactory：

```java
public class AppForBeanFactory {
    public static void main(String[] args) {
        Resource resources = new ClassPathResource("applicationContext.xml");
        BeanFactory bf = new XmlBeanFactory(resources);
        UserService userService = bf.getBean(UserService.class);
        userService.login();
    }
}
```

​		BeanFactory是延迟加载，只有在获取bean对象的时候才会去创建，ApplicationContext是立即加载，容器加载的时候就会创建bean对象。

​		ApplicationContext要想成为延迟加载，需要在applicationContext.xml中的bean标签中加`lazy-init=true`的属性



### 1.7 注解开发

​		注解开发同样要在pom文件导入Spring-content的坐标，在resources目录下配置Spring核心配置文件application.properties。

#### 1.7.1 半注解定义Bean

​		首先，项目结构如下：

<img src="/assets/SSM.assets/image-20240525184921172.png" alt="image-20240525184921172" style="zoom:67%;">

​		如果要把UserServiceImpl交给IOC容器管理，首先要在UserServiceImpl的类上加注解`@Component`

```java
@Component("userService")
public class UserServiceImpl implements UserService {
    public void login() {
        System.out.println("User login");
    }
}
```

> @Component("userService")相当于xml文件中的
>
> `<bean id="userService" class="com.lysssyo.service.Impl.UserServiceImpl"/>`
>
> `@Component`相当于bean标签，`"userService"`相当于`id="userService"`，写在UserServiceImpl相当于`class=......Impl`

​		然后配置Spring的注解包扫描

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       <!--开启了context命名空间-->
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
            http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd">
    
    <context:component-scan base-package="com.lysssyo"/>
    
</beans>
```

> `context:component-scan` 元素用于启用Spring的组件扫描功能。
>
> `base-package="com.lysssyo"` 指定了组件扫描的基础包，即Spring会扫描`com.lysssyo`包及其子包中的类，寻找带有Spring注解（例如`@Component`, `@Service`, `@Repository`, `@Controller`等）的类，**并将这些类注册为SpringIOC容器中的bean**。

​		最后：

```java
public class SpringDemo {
    public static void main(String[] args) {
        //加载配置文件得到上下文对象，也就是容器对象
        ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");
        UserService userService = ctx.getBean(UserServiceImpl.class);
        userService.login();
    }
}
```

​		正常运行

> 因为这里是按类型找Bean对象，所以可以不指定Bean对象的名字
>
> @Component注解如果不起名称，会有一个默认值就是`当前类名首字母小写`。

​		对于@Component注解，还衍生出了其他三个注解`@Controller`、`@Service`、`@Repository`。效果与@Component一样



#### 1.7.2  纯注解定义Bean

​	不再需要application.xml，而是用一个类来替换它

1. 创建一个配置类`SpringConfig`

```java
@Configuration
public class SpringConfig {
}
```

​		这个类相当于初始的application.xml文件

2. 用注解替换包扫描配置

```java
@Configuration
@ComponentScan("com.lysssyo")
public class SpringConfig {
}
```

3. `ApplicationContext`的实现类改为`AnnotationConfigApplicationContext`

```java
public class SpringDemo {
    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        UserService userService = (UserService) ctx.getBean("userServiceImpl");
        userService.login();
    }
}
```

​		运行：

![image-20240525191017318](/assets/SSM.assets/image-20240525191017318.png)



#### 1.7.3 bean作用范围与生命周期管理



#### 1.7.4 依赖注入

##### 1.7.4.1 Bean对象注入

​		对于UserController：

```java
@Controller
public class UserController {
    private UserService userService;

    public void setUserService(UserService userService) {
        this.userService = userService;
    }

    public void login(){
        userService.login();
    }

}
```

​		如果我们要以xml开发的方式注入UserService，需要为UserService写一个set方法，然后要在appication.xml的UserController的Bean标签中添加`<property name="userService" ref="userService"/>`

​		而如果用注解开发的方式，只需要在`private UserService userService;`上面加`@Autowired`

```java
@Controller
public class UserController {
    @Autowired
    private UserService userService;

    public void login(){
        userService.login();
    }

}
```

​		运行类：

```java
public class SpringDemo {
    public static void main(String[] args) {
        ApplicationContext ctx = new AnnotationConfigApplicationContext(SpringConfig.class);
        UserController userController =  ctx.getBean(UserController.class);
        userController.login();
    }
}
```

![image-20240525193852312](/assets/SSM.assets/image-20240525193852312.png)

- 为什么setter方法可以删除呢?

​		自动装配基于反射设计创建对象并通过暴力反射为私有属性进行设值，普通反射只能获取public修饰的内容，暴力反射除了获取public修饰的内容还可以获取private修改的内容，所以此处无需提供setter方法

- **@Autowired是按照类型注入**，那么对应UserService接口如果有多个实现类，就会报错

- @Autowired注解下面加@Qualifier注解可以实现按名称注入

```java
//UserController.java
	@Autowired
    @Qualifier("userServiceImpl")
    private UserService userService;
```

> 没有意义，本来依赖注入就是为了解耦，这些写不就又耦合上了吗

##### 1.7.4.2 简单数据类型注入

```java
public class JdbcConfig {
    @Value("${jdbc.driver}")
    private String driver;
    @Value("${jdbc.url}")
    private String url;
    @Value("${jdbc.root}")
    private String userName;
    @Value("${jdbc.password}")
    private String password;
    @Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(userName);
        ds.setPassword(password);
        return ds;
    }
}
```



#### 1.7.4 注解方式管理第三方Bean

1. 导入Jar包

```xml
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.16</version>
</dependency>
```

2. 写druid的配置类JdbcConfig，类上添加注解@Bean，交给IOC容器管理

```java
public class JdbcConfig {
	@Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName("com.mysql.jdbc.Driver");
        ds.setUrl("jdbc:mysql://localhost:3306/spring_db");
        ds.setUsername("root");
        ds.setPassword("root");
        return ds;
    }
}
```

3. Spring-Config使用`@Import`注解手动引入需要加载的配置类JdbcConfig

```java
@Configuration
@Import({JdbcConfig.class})
public class SpringConfig {
	
}
```



#### 1.7.5 为第三方Bean引入资源

​		上目中，`ds.setDriverClassName`采用的是硬编码的方式，不好，应该是从properties配置文件中读取。

1. 写一个Jdbc.properties

```properties
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/mybatis_test
jdbc.username=root
jdbc=password=123456
```

2. SpringConfig类上加一个注解：`@PropertySource("classpath:Jdbc.properties")`

​		Spring会读取并加载这个属性文件中的所有属性，并将它们添加到Spring环境中。这些属性可以在Spring的`@Value`注解中使用，或者通过`Environment`对象访问。

3. 修改JdbcConfig

```java
public class JdbcConfig {
    @Value("${jdbc.driver}")
    private String driver;
    @Value("${jdbc.url}")
    private String url;
    @Value("${jdbc.root}")
    private String userName;
    @Value("${jdbc.password}")
    private String password;
    @Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(userName);
        ds.setPassword(password);
        return ds;
    }
}
```

​		如果要引入DataSource方法（即定义Bean对象的方法），只需要为bean定义方法设置形参即可，容器会根据形参类型自动装配对象（如果IOC容器中有这个类型）。



### 1.8 AOP

#### 1.8.1 准备工作

1. 导入maven坐标

```xml
        <dependency>
            <groupId>org.aspectj</groupId>
            <artifactId>aspectjweaver</artifactId>
            <version>1.9.6</version>
        </dependency>
```

2. SpringConfig启用基于注解的 AspectJ 自动代理功能。通过在配置类上添加 @EnableAspectJAutoProxy 注解，Spring 将会为使用 @Aspect 注解的类创建代理，并将它们应用于相应的切点。

```java
@Configuration
@ComponentScan("com.lysssyo")
@EnableAspectJAutoProxy
public class SpringConfig {
}
```

3. 编写通知类

```java
@Component
@Aspect
public class MyAdvice {
    @Pointcut("execution(void com.lysssyo.service.UserService.login())")
    private void pt(){}

    @Before("pt()")
    public void method() {
        System.out.println("当前系统时间为：" + System.currentTimeMillis());
    }
}
```



#### 1.8.2 工作流程

1. Spring容器启动

​		容器启动就需要去加载bean（不等于初始化bean）



2. 读取所有切面配置中的切入点

<img src="/assets/SSM.assets/1630151682428.png" alt="1630151682428" style="zoom:50%;">

​		上面这个例子中有两个切入点的配置，但是第一个`ptx()`并没有被使用，所以不会被读取。



3. 初始化bean

​		判定bean对应的类中的方法是否匹配到任意切入点（注意第1步在容器启动的时候，bean对象还没有被创建成功）

![1630152538083](/assets/SSM.assets/1630152538083.png)

* 匹配失败，创建原始对象，如`UserDao`
* 匹配成功，创建原始对象（目标对象）的代理对象（proxy）,如:`BookDao`



4. 获取bean执行方法

* 获取的bean是原始对象时，调用方法并执行，完成操作
* 获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作



#### 1.8.3 切入点表达式

​		切入点表达式是描述切入点方法的一种表达式，主要用来决定项目中的哪些方法需要加入通知。

​		常见形式：

1. execution(……)：根据方法的签名来匹配

![image-20230110214150215](/assets/SSM.assets/image-20230110214150215.png)

2. @annotation(……) ：根据注解匹配

![image-20230110214242083](/assets/SSM.assets/image-20230110214242083.png)



##### 1.8.3.1 @execution

​		execution主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配，语法为：

~~~
execution(访问修饰符?  返回值  包名.类名.?方法名(方法参数) throws异常?)
~~~

其中带`?`的表示可以省略的部分

- 访问修饰符：可省略（比如: public、protected）

- 包名.类名：可省略

- throws 异常：可省略（注意是方法上声明抛出的异常，不是实际抛出的异常）

示例：

~~~java
@Before("execution(void com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer))")
~~~



可以使用通配符描述切入点

- `*` ：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的**一个参数**，**也可以通配`包.类.方法名`的一部分**

- `..` ：多个连续的任意符号，可以通配任意层级的包，或任意类型、任意个数的参数



切入点表达式的语法规则：

1. 方法的访问修饰符可以省略
2. 返回值可以使用`*`号代替（任意返回值类型）
3. 包名可以使用`*`号代替，代表任意包（一层包使用一个`*`）
4. 使用`..`配置包名，标识此包以及此包下的所有子包
5. 类名可以使用`*`号代替，标识任意类
6. 方法名可以使用`*`号代替，表示任意方法
7. 可以使用 `*`  配置参数，一个任意类型的参数
8. 可以使用`..` 配置参数，任意个任意类型的参数



**切入点表达式示例**

- 省略方法的访问修饰

  ~~~java
  execution(void com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer))
  ~~~

- 使用`*`代替返回值类型

  ~~~java
  execution(* com.itheima.service.impl.DeptServiceImpl.delete(java.lang.Integer))
  ~~~

- 使用`*`代替包名（一层包使用一个`*`）

  ~~~java
  execution(* com.itheima.*.*.DeptServiceImpl.delete(java.lang.Integer))
  ~~~

- 使用`..`省略包名

  ~~~java
  execution(* com..DeptServiceImpl.delete(java.lang.Integer))    
  ~~~

- 使用`*`代替类名

  ~~~java
  execution(* com..*.delete(java.lang.Integer))   
  ~~~

- 使用`*`代替方法名

  ~~~java
  execution(* com..*.*(java.lang.Integer))   
  ~~~

- 使用 `*` 代替参数

  ```java
  execution(* com.itheima.service.impl.DeptServiceImpl.delete(*))
  ```

- 使用`..`省略参数

  ~~~java
  execution(* com..*.*(..))
  ~~~

​	

注意事项：

- 根据业务需要，可以使用 且（&&）、或（||）、非（!） 来组合比较复杂的切入点表达式。

  ```java
  execution(* com.itheima.service.DeptService.list(..)) || execution(* com.itheima.service.DeptService.delete(..))
  ```

  

切入点表达式的书写建议：

- 所有业务方法名在命名时尽量规范，方便切入点表达式快速匹配。如：查询类方法都是 find 开头，更新类方法都是update开头

  ~~~java
  //业务类
  @Service
  public class DeptServiceImpl implements DeptService {
      
      public List<Dept> findAllDept() {
         //省略代码...
      }
      
      public Dept findDeptById(Integer id) {
         //省略代码...
      }
      
      public void updateDeptById(Integer id) {
         //省略代码...
      }
      
      public void updateDeptByMoreCondition(Dept dept) {
         //省略代码...
      }
      //其他代码...
  }
  ~~~

  ~~~java
  //匹配DeptServiceImpl类中以find开头的方法
  execution(* com.itheima.service.impl.DeptServiceImpl.find*(..))
  ~~~

- 描述切入点方法通常基于接口描述，而不是直接描述实现类，增强拓展性

  ~~~java
  execution(* com.itheima.service.DeptService.*(..))
  ~~~

- 在满足业务需要的前提下，尽量缩小切入点的匹配范围。如：包名匹配尽量不使用 ..，使用 * 匹配单个包

  ~~~java
  execution(* com.itheima.*.*.DeptServiceImpl.find*(..))
  ~~~

  

##### 1.8.3.2 @annotation

实现步骤：

1. 编写自定义注解

2. 在业务类要做为连接点的方法上添加自定义注解

   

**自定义注解**：MyLog

~~~java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyLog {
}
~~~



**业务类**：DeptServiceImpl

~~~java
@Slf4j
@Service
public class DeptServiceImpl implements DeptService {
    @Autowired
    private DeptMapper deptMapper;

    @Override
    @MyLog //自定义注解（表示：当前方法属于目标方法）
    public List<Dept> list() {
        List<Dept> deptList = deptMapper.list();
        //模拟异常
        //int num = 10/0;
        return deptList;
    }

    @Override
    @MyLog  //自定义注解（表示：当前方法属于目标方法）
    public void delete(Integer id) {
        //1. 删除部门
        deptMapper.delete(id);
    }


    @Override
    public void save(Dept dept) {
        dept.setCreateTime(LocalDateTime.now());
        dept.setUpdateTime(LocalDateTime.now());
        deptMapper.save(dept);
    }

    @Override
    public Dept getById(Integer id) {
        return deptMapper.getById(id);
    }

    @Override
    public void update(Dept dept) {
        dept.setUpdateTime(LocalDateTime.now());
        deptMapper.update(dept);
    }
}
~~~



**切面类**

~~~java
@Slf4j
@Component
@Aspect
public class MyAspect6 {
    //针对list方法、delete方法进行前置通知和后置通知

    //前置通知
    @Before("@annotation(com.itheima.anno.MyLog)")
    public void before(){
        log.info("MyAspect6 -> before ...");
    }

    //后置通知
    @After("@annotation(com.itheima.anno.MyLog)")
    public void after(){
        log.info("MyAspect6 -> after ...");
    }
}
~~~

重启SpringBoot服务，测试查询所有部门数据，查看控制台日志：

![image-20230110224447047](/assets/SSM.assets/image-20230110224447047.png)



总结：

- execution切入点表达式
  - 根据我们所指定的方法的描述信息来匹配切入点方法，这种方式也是最为常用的一种方式
  - 如果我们要匹配的切入点方法的方法名不规则，或者有一些比较特殊的需求，通过execution切入点表达式描述比较繁琐
- annotation 切入点表达式
  - 基于注解的方式来匹配切入点方法。这种方式虽然多一步操作，我们需要自定义一个注解，但是相对来比较灵活。我们需要匹配哪个方法，就在方法上加上对应的注解就可以了



#### 1.8.4 通知类型

​		Spring中AOP的通知类型：

- @Around：环绕通知，此注解标注的通知方法在目标方法前、后都被执行
- @Before：前置通知，此注解标注的通知方法在目标方法前被执行
- @After ：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行
- @AfterReturning ：返回后通知，此注解标注的通知方法在目标方法返回后被执行，有异常不会执行
- @AfterThrowing ：异常后通知，此注解标注的通知方法发生异常后执行



​		不同类型对于原始方法的返回值的影响：

- **@Around**：能直接影响和修改目标方法的返回值。

- **@Before** 和 **@After**和**AfterThrowing**：无法访问目标方法的返回值。
- **@AfterReturning**：可以访问但不能修改返回值。

​		如果**@Around**在切面中没有处理原始方法的返回值，原始方法不能正常返回。

​		例如原始方法会返回一个String类型的字符串，如果在**@Around**类型的切面中没有处理返回值，就会返回空

~~~java
@Slf4j
@Component	//交给IOC容器管理
@Aspect		//以下定义的是切面类
public class MyAspect1 {
    //前置通知
    @Before("execution(* com.itheima.service.*.*(..))")
    public void before(JoinPoint joinPoint){
        log.info("before ...");

    }

    //环绕通知
    @Around("execution(* com.itheima.service.*.*(..))")
    public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        log.info("around before ...");

        //调用目标对象的原始方法执行
        Object result = proceedingJoinPoint.proceed();
        
        //原始方法如果执行时有异常，环绕通知中的后置代码不会在执行了        
        log.info("around after ...");
        // 这个return非常重要，如果没有，原始方法不能正常返回
        return result;
    }
    
    //后置通知
    @After("execution(* com.itheima.service.*.*(..))")
    public void after(JoinPoint joinPoint){
        log.info("after ...");
    }

    //返回后通知（程序在正常执行的情况下，会执行的后置通知）
    @AfterReturning("execution(* com.itheima.service.*.*(..))")
    public void afterReturning(JoinPoint joinPoint){
        log.info("afterReturning ...");
    }

    //异常通知（程序在出现异常的情况下，执行的后置通知）
    @AfterThrowing("execution(* com.itheima.service.*.*(..))")
    public void afterThrowing(JoinPoint joinPoint){
        log.info("afterThrowing ...");
    }
}

~~~

- @Around环绕通知需要自己调用 ProceedingJoinPoint.proceed() 来让原始方法执行，其他通知不需要考虑目标方法执行
- @Around环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值，否则原始方法执行完毕，是获取不到返回值的。



#### 1.8.5 获取数据

##### 1.8.5.1 参数

​		所有类型的通知都可以通过JointPoint获取参数

```java
    @Before("pt()")
    public void method(JoinPoint joinPoint) throws Throwable {
        Object[] args = joinPoint.getArgs();//获取参数
        System.out.println(Arrays.toString(args));//参数是Object类型的数组转为String
    }
```

​		特别的，环绕通知Around调用原始方法运行的函数proceed()有两个，有参和无参：

![image-20240527141851904](/assets/SSM.assets/image-20240527141851904.png)

​		所以，获取到参数之后，可以修改之再传给proceed，改变原始方法的实际参数

> 如果传来的参数有问题就可以在这里修改，保证程序的健壮性

##### 1.8.5.2 返回值

​		只有AfterReturning和Around类型的通知可以拿到原始方法的返回值。

- Around类型：

```java
    @Around("pt()")
    public void method(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        Object[] args = proceedingJoinPoint.getArgs();
        System.out.println(Arrays.toString(args));
        Object res = proceedingJoinPoint.proceed();//res 为原始方法的返回值
        System.out.println(res.toString());
    }
```

- AfterReturning类型

```java
    @AfterReturning(value = "pt()",returning = "res")
    public void method(Object res) throws Throwable {
        System.out.println(res);
    }
```

​		注解中通过returning属性表明形参中object类型的res用来接收原始方法的返回值



##### 1.8.5.3 异常

​		只有AfterThrowing才可以接收异常

```java
    @AfterThrowing(value = "pt()", throwing = "t")
    public void method(JoinPoint joinPoint, Throwable t) throws Throwable {
        System.out.println(t);
    }
```





### 1.9 事务

#### 1.9.1 开启事物

​		Spring为了管理事务，提供了一个平台事务管理器`PlatformTransactionManager`

![1630243651541](/assets/SSM.assets/1630243651541.png)

​		commit是用来提交事务，rollback是用来回滚事务。

​		PlatformTransactionManager只是一个接口，Spring还为其提供了一个具体的实现：

![1630243993380](/assets/SSM.assets/1630243993380.png)

​		从名称上可以看出，我们只需要给它一个DataSource对象，它就可以帮你去在业务层管理事务。其内部采用的是JDBC的事务。所以说如果你持久层采用的是JDBC相关的技术，就可以采用这个事务管理器来管理你的事务。而Mybatis内部采用的就是JDBC的事务，所以后期我们Spring整合Mybatis就采用的这个DataSourceTransactionManager事务管理器。

​	Spring事务管理具体的实现步骤为：

1. 在SpringConfig的配置类中开启事物注解

```java
@Configuration
@ComponentScan("com.itheima")
@PropertySource("classpath:jdbc.properties")
@Import({JdbcConfig.class,MybatisConfig.class})
//开启注解式事务驱动
@EnableTransactionManagement
public class SpringConfig {
}
```



2. 在JdbcConfig类中配置事务管理器

```java
public class JdbcConfig {
    @Value("${jdbc.driver}")
    private String driver;
    @Value("${jdbc.url}")
    private String url;
    @Value("${jdbc.username}")
    private String userName;
    @Value("${jdbc.password}")
    private String password;

    @Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(userName);
        ds.setPassword(password);
        return ds;
    }

    //配置事务管理器，mybatis使用的是jdbc事务
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource){
        DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();
        transactionManager.setDataSource(dataSource);
        return transactionManager;
    }
}
```



3. 在需要被事务管理的方法上添加注解

```java
public interface AccountService {
    /**
     * 转账操作
     * @param out 传出方
     * @param in 转入方
     * @param money 金额
     */
    //配置当前接口方法具有事务
    public void transfer(String out,String in ,Double money) ;
}

@Service
public class AccountServiceImpl implements AccountService {

    @Autowired
    private AccountDao accountDao;
	@Transactional
    public void transfer(String out,String in ,Double money) {
        accountDao.outMoney(out,money);
        int i = 1/0;
        accountDao.inMoney(in,money);
    }

}
```

@Transactional可以写在接口类上、接口方法上、实现类上和实现类方法上

* 写在接口类上，该接口的所有实现类的所有方法都会有事务
* 写在接口方法上，该接口的所有实现类的该方法都会有事务
* 写在实现类上，该类中的所有方法都会有事务
* 写在实现类方法上，该方法上有事务
* **建议写在实现类或实现类的方法上**



#### 1.9.2 事物角色

1. 未开启Spring事务之前：

![1630248794837](/assets/SSM.assets/1630248794837.png)

​		AccountDao的outMoney因为是修改操作，会开启一个事务T1。AccountDao的inMoney因为是修改操作，会开启一个事务T2。AccountService的transfer没有事务，运行过程中如果没有抛出异常，则T1和T2都正常提交，数据正确。如果在两个方法中间抛出异常，T1因为执行成功提交事务，T2因为抛异常不会被执行，就会导致数据出现错误

2. 开启Spring的事务管理后

![1630249111055](/assets/SSM.assets/1630249111055.png)

* transfer上添加了@Transactional注解，在该方法上就会有一个事务T
* AccountDao的outMoney方法的事务T1加入到transfer的事务T中
* AccountDao的inMoney方法的事务T2加入到transfer的事务T中
* 这样就保证他们在同一个事务中，当业务层中出现异常，整个事务就会回滚，保证数据的准确性。

通过上面例子的分析，我们就可以得到如下概念:

- 事务管理员：发起事务方，在Spring中通常指代业务层开启事务的方法
- 事务协调员：加入事务方，在Spring中通常指代数据层方法，也可以是业务层方法

#### 1.9.3 Spring事务属性

![1630250069844](/assets/SSM.assets/1630250069844.png)

上面这些属性都可以在`@Transactional`注解的参数上进行设置。

* readOnly：true只读事务，false读写事务，增删改要设为false,查询设为true。
* timeout：设置超时时间单位秒，在多长时间之内事务没有提交成功就自动回滚，-1表示不设置超时时间。
* rollbackFor：当出现指定异常进行事务回滚
* noRollbackFor：当出现指定异常不进行事务回滚
* isolation设置事务的隔离级别

  * DEFAULT   :默认隔离级别, 会采用数据库的隔离级别
  * READ_UNCOMMITTED : 读未提交
  * READ_COMMITTED : 读已提交
  * REPEATABLE_READ : 重复读取
  * SERIALIZABLE: 串行化

​		rollbackFor是指定回滚异常，对于异常事务不应该都回滚么，为什么还要指定?因为并不是所有的异常都会回滚事务，比如下面的代码就不会回滚，Spring的事务只会对`Error异常`和`RuntimeException异常`及其子类进行事务回滚，其他的异常类型是不会回滚的，例如IOException不符合上述条件所以不回滚。

​		此时就可以使用rollbackFor属性来设置出现IOException异常不回滚：

```java
@Service
public class AccountServiceImpl implements AccountService {

    @Autowired
    private AccountDao accountDao;
	@Transactional(rollbackFor = {IOException.class})
    public void transfer(String out,String in ,Double money) throws IOException{
        accountDao.outMoney(out,money);
        //int i = 1/0; //这个异常事务会回滚
        if(true){
            throw new IOException(); //这个异常事务就不会回滚
        }
        accountDao.inMoney(in,money);
    }

}
```



#### 1.9.4 事务传播行为

​		为转账操作记录日志，无论是否成功：

![image-20240527164616043](/assets/SSM.assets/image-20240527164616043.png)

​		以上是失败的。

​		log方法、inMoney方法和outMoney方法都属于增删改，分别有事务T1,T2,T3。transfer因为加了@Transactional注解，也开启了事务，Spring事务会把T1,T2,T3都加入到事务T中，所以当转账失败后，所有的事务都回滚，导致日志没有记录下来，这和我们的需求不符，这个时候我们就想能不能让log方法单独是一个事务呢?

​		要想解决这个问题，就需要用到事务传播行为，所谓的事务传播行为指的是——事务协调员对事务管理员所携带事务的处理态度。

```java
@Service
public class LogServiceImpl implements LogService {

    @Autowired
    private LogDao logDao;
	//propagation设置事务属性：传播行为设置为当前操作需要新事务
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void log(String out,String in,Double money ) {
        logDao.log("转账操作由"+out+"到"+in+",金额："+money);
    }
}
```

​		运行后，就能实现我们想要的结果，不管转账是否成功，都会记录日志。

​	事务传播行为的可选值：

![1630254257628](/assets/SSM.assets/1630254257628.png)

​		对于我们开发实际中使用的话，因为默认值需要事务是常态的。根据开发过程选择其他的就可以了，例如案例中需要新事务就需要手工配置。其实入账和出账操作上也有事务，采用的就是默认值。















## 2. SpringMVC

### 2.1 SpringMVC简介

​		SpringMVC是一种基于Java实现MVC模型的轻量级Web框架。

​		SpringMVC主要负责的就是：

* controller如何接收请求和数据
* 如何将请求和数据转发给业务层
* 如何将响应数据转换成json发回到前端

![image-20240528182413089](/assets/SSM.assets/image-20240528182413089.png)













### 2.2 起步Demo

1. 使用骨架创建Web项目

   1. EmptyProje新建一个Module

   <img src="/assets/SSM.assets/image-20240528111806861.png" alt="image-20240528111806861" style="zoom:150%;">

   2. 在ProjectStructure中点击新建的Module，右键main添加一个Folder命名为java并设置为source

![image-20240528111815711](/assets/SSM.assets/image-20240528111815711.png)

2. pom文件导入坐标

```xml
    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>3.1.0</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>5.2.10.RELEASE</version>
    </dependency>
```

3. 导入tomcat相关插件

```xml
  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.tomcat.maven</groupId>
        <artifactId>tomcat7-maven-plugin</artifactId>
        <version>2.1</version>
        <configuration>
          <port>80</port>
          <path>/</path>
        </configuration>
      </plugin>
    </plugins>
  </build>
```

**说明：**servlet的坐标为什么需要添加`<scope>provided</scope>`?

​		scope是maven中jar包依赖作用范围的描述，如果不设置默认是`compile`在在编译、运行、测试时均有效。如果运行有效的话就会和tomcat中的servlet-api包发生冲突，导致启动报错。provided代表的是该包只在编译和测试的时候用，运行的时候无效直接使用tomcat中的，就避免冲突

4. 创建SpringMvcConfig配置类

```java
@Configuration
@ComponentScan("com.lysssyo.controller")
public class SpringMvcConfig {
}
```

5. 将web.xml删除，换成ServletContainersInitConfig

```java
public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer {
    //加载springmvc配置类
    protected WebApplicationContext createServletApplicationContext() {
        //初始化WebApplicationContext对象
        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();
        //加载指定配置类
        ctx.register(SpringMvcConfig.class);
        return ctx;
    }

    //设置由springmvc控制器处理的请求映射路径
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }

    //加载spring配置类
    protected WebApplicationContext createRootApplicationContext() {
        return null;
    }
}
```

6. 写Controller

```java
@Controller
public class UserController {
    @RequestMapping("/save")
    @ResponseBody
    public String save(){
        System.out.println("user save ...");
        return "{'info':'springmvc'}";
    }
}
```

7. 配置Tomcat环境

![image-20240528112251036](/assets/SSM.assets/image-20240528112251036.png)

8. 启动项目

![image-20240528112315607](/assets/SSM.assets/image-20240528112315607.png)



### 2.3 启动服务器初始化过程

1. 服务器启动，执行ServletContainersInitConfig类，初始化web容器

   * 功能类似于以前的web.xml

2. 执行createServletApplicationContext方法，创建了WebApplicationContext对象

   * 该方法加载SpringMVC的配置类SpringMvcConfig来初始化SpringMVC的容器

     * 执行@ComponentScan加载对应的bean

     * 扫描指定包及其子包下所有类上的注解，如Controller类上的@Controller注解

3. 加载UserController，每个@RequestMapping的名称对应一个具体的方法

   ```java
   @Controller
   public class UserController {
       @RequestMapping("/save")
       @ResponseBody
       public String save(){
           System.out.println("user save ...");
           return "{'info':'springmvc'}";
       }
   }
   ```

   > 此时就建立了 `/save` 和 save方法的对应关系

4. 执行getServletMappings方法，设定SpringMVC拦截请求的路径规则

   ```java
       //设置由springmvc控制器处理的请求映射路径
       protected String[] getServletMappings() {
           return new String[]{"/"};
       }
   ```

   * `/`代表所拦截请求的路径规则，只有被拦截后才能交给SpringMVC来处理请求



### 2.4 单次请求过程

1. 发送请求`http://localhost/save`
2. web容器发现该请求满足SpringMVC拦截规则，将请求交给SpringMVC处理
3. 解析请求路径/save
4. 由/save匹配执行对应的方法save(）
   * 上面的第三步已经将请求路径和方法建立了对应关系，通过/save就能找到对应的save方法
5. 执行save()
6. 检测到有@ResponseBody直接将save()方法的返回值**作为响应体**返回给请求方



### 2.5 Bean加载控制

* SpringMVC加载其相关bean(表现层bean),也就是controller包下的类
* Spring控制的bean
  * 业务bean(Service)
  * 功能bean(DataSource,SqlSessionFactoryBean,MapperScannerConfigurer等)

​	因为功能不同，如何避免Spring错误加载到SpringMVC的bean?

解决：

​	在SpringMVC的配置类`SpringMvcConfig`中使用注解`@ComponentScan`，我们只需要将其扫描范围设置到controller即可

```java
@Configuration
@ComponentScan("com.lysssyo.controller")
public class SpringMvcConfig {
}
```

​		对于Spring，加载Spring控制的bean的时候排除掉SpringMVC控制的bean

- 方式一：修改Spring配置类，设定扫描范围为精准范围。

```java
@Configuration
@ComponentScan({"com.itheima.service","comitheima.dao"})
public class SpringConfig {
}
```

> 上述只是通过例子说明可以精确指定让Spring扫描对应的包结构，真正在做开发的时候，因为Dao最终是交给`MapperScannerConfigurer`对象来进行扫描处理的，我们只需要将其扫描到service包即可。

- 方式二：修改Spring配置类，设定扫描范围为com.itheima,排除掉controller包中的bean

```java
@Configuration
@ComponentScan(value="com.itheima",
    excludeFilters=@ComponentScan.Filter(
    	type = FilterType.ANNOTATION,
        classes = Controller.class
    )
)
public class SpringConfig {
}
```

> - excludeFilters属性：设置扫描加载bean时，排除的过滤规则
>
> - type属性：设置排除规则，当前使用按照bean定义时的注解类型进行排除
>
>   * ANNOTATION：按照注解排除
>
>   * ASSIGNABLE_TYPE:按照指定的类型过滤
>
>   * ASPECTJ:按照Aspectj表达式排除，基本上不会用
>
>   * REGEX:按照正则表达式排除
>
>   * CUSTOM:按照自定义规则排除
>
>
> - classes属性：设置排除的具体注解类，当前设置排除@Controller定义的bean

​		有了Spring的配置类，要想在tomcat服务器启动将其加载，我们需要修改ServletContainersInitConfig

```java
public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer {
    protected WebApplicationContext createServletApplicationContext() {
        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();
        ctx.register(SpringMvcConfig.class);
        return ctx;
    }
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
    protected WebApplicationContext createRootApplicationContext() {
      AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();
        ctx.register(SpringConfig.class);
        return ctx;
    }
}
```

​		对于上述的配置方式，Spring还提供了一种更简单的配置方式，可以不用再去创建`AnnotationConfigWebApplicationContext`对象，不用手动`register`对应的配置类。

```java
public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
    protected Class<?>[] getRootConfigClasses() {
        return new Class[]{SpringConfig.class};
    }

    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{SpringMvcConfig.class};
    }

    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}
```



## 3. SSM整合

### 3.1 起步配置

1. 使用骨架创建Web项目

   1. EmptyProje新建一个Module

   <img src="/assets/SSM.assets/image-20240528111806861.png" alt="image-20240528111806861" style="zoom:150%;">

   2. 在ProjectStructure中点击新建的Module，右键main添加一个Folder命名为java并设置为source，右键src添加一个Folder命名为test下面再建一个java设置为test。

   ![image-20240528111815711](/assets/SSM.assets/image-20240528111815711.png)

   3. 把web-app中的WEB-INF里面全部xml删去

2. pom文件导入坐标

```xml
 <dependencies>
    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-webmvc</artifactId>
      <version>5.2.10.RELEASE</version>
    </dependency>

    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-jdbc</artifactId>
      <version>5.2.10.RELEASE</version>
    </dependency>

    <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-test</artifactId>
      <version>5.2.10.RELEASE</version>
    </dependency>

    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis</artifactId>
      <version>3.5.6</version>
    </dependency>

    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis-spring</artifactId>
      <version>1.3.0</version>
    </dependency>

    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>5.1.47</version>
    </dependency>

    <dependency>
      <groupId>com.alibaba</groupId>
      <artifactId>druid</artifactId>
      <version>1.1.16</version>
    </dependency>

    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.12</version>
      <scope>test</scope>
    </dependency>

    <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>javax.servlet-api</artifactId>
      <version>3.1.0</version>
      <scope>provided</scope>
    </dependency>

    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>2.9.0</version>
    </dependency>
  </dependencies>
```

3. 导入tomcat相关插件

```xml
  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.tomcat.maven</groupId>
        <artifactId>tomcat7-maven-plugin</artifactId>
        <version>2.1</version>
        <configuration>
          <port>80</port>
          <path>/</path>
        </configuration>
      </plugin>
    </plugins>
  </build>
```

4. 创建SpringConfig，JdbcConfig，MyBatisConfig，ServletContainerInitConfig，SpringMvcConfig以及jdbc.properties

```java
//SpringConfig
@Configuration
@ComponentScan({"com.lysssyo.service"})
@PropertySource("classpath:Jdbc.properties")
@Import({MyBatisConfig.class,JdbcConfig.class})
public class SpringConfig {
}
```



```java
//JdbcConfig
public class JdbcConfig {
    @Value("${jdbc.driver}")
    private String driver;
    @Value("${jdbc.url}")
    private String url;
    @Value("${jdbc.root}")
    private String userName;
    @Value("${jdbc.password}")
    private String password;
    @Bean
    public DataSource dataSource(){
        DruidDataSource ds = new DruidDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        ds.setUsername(userName);
        ds.setPassword(password);
        return ds;
    }
}
```



```java
//MyBatisConfig
public class MyBatisConfig {
    @Bean
    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) {
        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setTypeAliasesPackage("com.lysssyo.pojo");
        sqlSessionFactoryBean.setDataSource(dataSource);
        return sqlSessionFactoryBean;
    }

    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer(){
        MapperScannerConfigurer mapperScannerConfigurer=new MapperScannerConfigurer();
        mapperScannerConfigurer.setBasePackage("com.lysssyo.mapper");
        return  mapperScannerConfigurer;
    }
}
```



```java
//ServletContainerInitConfig
public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
    protected Class<?>[] getRootConfigClasses() {
        return new Class[]{SpringConfig.class};
        //返回包含 Spring 容器的配置类，制造一个容器对象
    }

    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{SpringMvcConfig.class};
        //返回包含 SpringMvc 容器的配置类，制造一个容器对象
    }
    //SpringMvcConfig的容器可以访问Spring的容器，反之不行

    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}
```



```java
//SpringMvcConfig
@Configuration
@ComponentScan("com.lysssyo.controller")
@EnableWebMvc
public class SpringMvcConfig {
}
```



```properties
#jdbc.properties
jdbc.driver=com.mysql.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/mybatis_test?userSSL=false
jdbc.username=root
jdbc=password=123456
```



### 3.2 异常处理器

1. 自定义异常

```java
//自定义异常处理器，用于封装异常信息，对异常进行分类
public class SystemException extends RuntimeException{
    private Integer code;

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public SystemException(Integer code, String message) {
        super(message);
        this.code = code;
    }

    public SystemException(Integer code, String message, Throwable cause) {
        super(message, cause);
        this.code = code;
    }

}

//自定义异常处理器，用于封装异常信息，对异常进行分类
public class BusinessException extends RuntimeException{
    private Integer code;

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public BusinessException(Integer code, String message) {
        super(message);
        this.code = code;
    }

    public BusinessException(Integer code, String message, Throwable cause) {
        super(message, cause);
        this.code = code;
    }
}
```

**说明:**

* 继承自`RuntimeException`的异常是非检查异常（unchecked exception），在编译时不强制要求处理。相比之下，继承自`Exception`的异常是检查异常（checked exception），编译时必须要么捕获要么声明抛出。非检查异常减少了代码中繁琐的异常处理逻辑，使代码更加简洁。
* 自定义异常类中添加`code`属性的原因是为了更好的区分异常是来自哪个业务的

2. 在需要的地方抛出异常

```java
public Book getById(Integer id) {
    //模拟业务异常，包装成自定义异常
    if(id == 1){
        throw new BusinessException(Code.BUSINESS_ERR,"请不要使用你的技术挑战我的耐性!");
    }
    //模拟系统异常，将可能出现的异常进行包装，转换成自定义异常
    try{
        int i = 1/0;
    }catch (Exception e){
        throw new SystemException(Code.SYSTEM_TIMEOUT_ERR,"服务器访问超时，请重试!",e);
    }
    return bookDao.getById(id);
}
```

3. 全局异常处理器统一处理异常

```java
//@RestControllerAdvice用于标识当前类为REST风格对应的异常处理器
@RestControllerAdvice
public class ProjectExceptionAdvice {
    //@ExceptionHandler用于设置当前处理器类对应的异常类型
    @ExceptionHandler(SystemException.class)
    public Result doSystemException(SystemException ex){
        return new Result(ex.getCode(),null,ex.getMessage());
    }

    @ExceptionHandler(BusinessException.class)
    public Result doBusinessException(BusinessException ex){
        return new Result(ex.getCode(),null,ex.getMessage());
    }

    //除了自定义的异常处理器，保留对Exception类型的异常处理，用于处理非预期的异常
    @ExceptionHandler(Exception.class)
    public Result doOtherException(Exception ex){
        return new Result(Code.SYSTEM_UNKNOW_ERR,null,"未知错误");
    }
}
```

<img src="/assets/SSM.assets/image-20240530162350686.png" alt="image-20240530162350686" style="zoom:67%;">



### 3.3 拦截器

​		拦截器（Interceptor）是一种动态拦截方法调用的机制，在SpringMVC中动态拦截控制器方法的执行

作用：

* 在指定的方法调用前后执行预先设定的代码
* 阻止原始方法的执行
* 总结：拦截器就是用来做增强

> 拦截器Interceptor与过滤器Filter的区别
>
> - 归属不同：Filter属于Servlet技术，Interceptor属于SpringMVC技术
> - 拦截内容不同：Filter对所有访问进行增强，Interceptor仅针对SpringMVC的访问进行增强

![1630676903190](/assets/SSM.assets/1630676903190.png)

#### 3.3.1 Demo

**步骤1:创建拦截器类**

```java
@Component
//定义拦截器类，实现HandlerInterceptor接口
//注意当前类必须受Spring容器控制
public class ProjectInterceptor implements HandlerInterceptor {
    @Override
    //原始方法调用前执行的内容
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("preHandle...");
        return true;
    }

    @Override
    //原始方法调用后执行的内容
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle...");
    }

    @Override
    //原始方法调用完成后执行的内容
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("afterCompletion...");
    }
}
```

> 拦截器类要被**SpringMVC容器**扫描到。
>
> 拦截器中的`preHandler`方法，如果返回true,则代表放行，会执行原始Controller类中要请求的方法，如果返回false，则代表拦截，后面的就不会再执行了。

**步骤2：配置拦截器类**

```java
@Configuration
public class SpringMvcSupport extends WebMvcConfigurationSupport {
    @Autowired
    private ProjectInterceptor projectInterceptor;

    @Override
    protected void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(projectInterceptor).addPathPatterns("/books","/books/*" );
    }
}
```

**步骤3：SpringMVC的配置类SpringMvcConfig导入拦截器的配置类SpringMvcSupport**

```java
@Configuration
@ComponentScan({"com.lysssyo.controller","com.lysssyo.handle","com.lysssyo.interceptor","com.lysssyo.config"})
@EnableWebMvc
public class SpringMvcConfig {
}
```

> ComponentScan中`"com.lysssyo.interceptor"`用于扫ProjectInterceptor，`com.lysssyo.config`用于扫SpringMvcSupport

项目结构：

<img src="/assets/SSM.assets/image-20240531111907502.png" alt="image-20240531111907502" style="zoom:67%;">



**步骤4：运行程序测试**

使用PostMan发送`http://localhost/books`

![1630678114224](/assets/SSM.assets/1630678114224.png)

​		如果发送`http://localhost/books/100`会发现拦截器没有被执行，原因是拦截器的`addPathPatterns`方法配置的拦截路径是`/books`,我们现在发送的是`/books/100`，所以没有匹配上，因此没有拦截，拦截器就不会执行。

**步骤5：修改拦截器拦截规则**

```java
@Configuration
public class SpringMvcSupport extends WebMvcConfigurationSupport {
    @Autowired
    private ProjectInterceptor projectInterceptor;

    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/pages/**").addResourceLocations("/pages/");
    }

    @Override
    protected void addInterceptors(InterceptorRegistry registry) {
        //配置拦截器
        registry.addInterceptor(projectInterceptor).addPathPatterns("/books","/books/*" );
    }
}
```

​		这个时候，如果再次访问`http://localhost/books/100`，拦截器就会被执行。

**步骤6：简化SpringMvcSupport的编写**

```java
@Configuration
@ComponentScan({"com.itheima.controller"})
@EnableWebMvc
//不写SpringMvcSupport，即不继承WebMvcConfigurationSupport。而是在SpringMvcConfig实现一个WebMvcConfigurer接口
//实现WebMvcConfigurer接口可以简化开发，但具有一定的侵入性
public class SpringMvcConfig implements WebMvcConfigurer {
    @Autowired
    private ProjectInterceptor projectInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //配置多拦截器
        registry.addInterceptor(projectInterceptor).addPathPatterns("/books","/books/*");
    }
}
```

此后咱们就不用再写`SpringMvcSupport`类了。

最后我们来看下拦截器的执行流程:

![1630679464294](/assets/SSM.assets/1630679464294.png)

#### 3.3.2 拦截器参数

​		**原始方法之前运行preHandle**

```java
public boolean preHandle(HttpServletRequest request,
                         HttpServletResponse response,
                         Object handler) throws Exception {
    System.out.println("preHandle");
    return true;
}
```

* request：请求对象
* response：响应对象
* handler：被调用的处理器对象，本质上是一个方法对象，对反射中的Method对象进行了再包装

使用request对象可以获取请求数据中的内容，如获取请求头的`Content-Type`

```java
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    String contentType = request.getHeader("Content-Type");
    System.out.println("preHandle..."+contentType);
    return true;
}
```

使用handler参数，可以获取方法的相关信息

```java
public boolean preHandle(HttpServletRequest request, 
                         HttpServletResponse response, 
                         Object handler) throws Exception {
    HandlerMethod hm = (HandlerMethod)handler;
    String methodName = hm.getMethod().getName();//可以获取方法的名称
    System.out.println("preHandle..."+methodName);
    return true;
}
```

​		**后置处理方法**

​		原始方法运行后运行，如果原始方法被拦截，则不执行

```java
public void postHandle(HttpServletRequest request,
                       HttpServletResponse response,
                       Object handler,
                       ModelAndView modelAndView) throws Exception {
    System.out.println("postHandle");
}
```

​		前三个参数和上面的是一致的。

​		modelAndView：如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整。但是因为咱们现在都是返回json数据，所以该参数的使用率不高。

​		**完成处理方法**

​		拦截器最后执行的方法，无论原始方法是否执行

```java
public void afterCompletion(HttpServletRequest request,
                            HttpServletResponse response,
                            Object handler,
                            Exception ex) throws Exception {
    System.out.println("afterCompletion");
}
```

​		前三个参数与上面的是一致的。

​		ex:如果处理器执行过程中出现异常对象，可以针对异常情况进行单独处理  。因为我们现在已经有全局异常处理器类，所以该参数的使用率也不高。这三个方法中，最常用的是==preHandle==,在这个方法中可以通过返回值来决定是否要进行放行，我们可以把业务逻辑放在该方法中，如果满足业务则返回true放行，不满足则返回false拦截。

#### 3.3.3  配置多个拦截器

**步骤1：创建拦截器类**

```java
@Component
public class ProjectInterceptor2 implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("preHandle...222");
        return false;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle...222");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("afterCompletion...222");
    }
}
```

**步骤2：配置拦截器类**

```java
@Configuration
@ComponentScan({"com.itheima.controller"})
@EnableWebMvc
//实现WebMvcConfigurer接口可以简化开发，但具有一定的侵入性
public class SpringMvcConfig implements WebMvcConfigurer {
    @Autowired
    private ProjectInterceptor projectInterceptor;
    @Autowired
    private ProjectInterceptor2 projectInterceptor2;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //配置多拦截器
        registry.addInterceptor(projectInterceptor).addPathPatterns("/books","/books/*");
        registry.addInterceptor(projectInterceptor2).addPathPatterns("/books","/books/*");
    }
}
```

步骤3:运行程序，观察顺序

![1630680435269](/assets/SSM.assets/1630680435269.png)

拦截器执行的顺序是和配置顺序有关。就和前面所提到的运维人员进入机房的案例，先进后出。

* 当配置多个拦截器时，形成拦截器链
* 拦截器链的运行顺序参照拦截器添加顺序为准
* 当拦截器中出现对原始处理器的拦截，后面的拦截器均终止运行
* 当拦截器运行中断，仅运行配置在前面的拦截器的afterCompletion操作

![1630680579735](/assets/SSM.assets/1630680579735.png)

preHandle：与配置顺序相同，必定运行

postHandle:与配置顺序相反，可能不运行

afterCompletion:与配置顺序相反，可能不运行。

这个顺序不太好记，最终只需要把握住一个原则即可:==以最终的运行结果为准==



## 4. SpringBoot 

​		SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程



### 4.1 SpringBoot快速启动

**pom文件添加插件：**

```xml
<plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
    <version>${spring-boot.version}</version>
    <configuration>
        <mainClass>com.lysssyo.SpringBootTestApplication</mainClass>
        <skip>false</skip>
        <!--设置为false很关键-->
    </configuration>
    <executions>
        <execution>
            <id>repackage</id>
            <goals>
                <goal>repackage</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

> 这个插件使maven在打包时不仅把自身程序打了进去，还把依赖的jar包也打了进去。（有点像打war包，详见Maven笔记）



**启动：**

进入 `jar` 包所在位置，在 `命令提示符` 中输入如下命令

```shell
jar -jar springboot_01_quickstart-0.0.1-SNAPSHOT.jar
```

执行上述命令就可以看到 `SpringBoot` 运行的日志信息

<img src="/assets/SSM.assets/image-20210911182956629.png" alt="image-20210911182956629" style="zoom:60%;">



#### 4.1.1 起步依赖

​	SpringBoot的pom文件：

<img src="/assets/SSM.assets/image-20240715150625288.png" alt="image-20240715150625288" style="zoom:67%;">

**starter**

* `SpringBoot` 中常见项目名称，定义了当前项目使用的所有项目坐标，以达到减少依赖配置的目的

**parent**

* 所有 `SpringBoot` 项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的

* `spring-boot-starter-parent`（2.5.0）与 `spring-boot-starter-parent`（2.4.6）共计57处坐标版本不同

**实际开发**

* 使用任意坐标时，仅书写GAV中的G和A，V由SpringBoot提供

  > G：groupid
  >
  > A：artifactId
  >
  > V：version

* 如发生坐标错误，再指定version（要小心版本冲突）



#### 4.1.2  程序启动

​	创建的每一个 `SpringBoot` 程序时都包含一个类似于下面的类，我们将这个类称作引导类

```java
@SpringBootApplication
public class Springboot01QuickstartApplication {    
    public static void main(String[] args) {
        SpringApplication.run(Springboot01QuickstartApplication.class, args);
    }
}
```

**注意：**

* `SpringBoot` 在创建项目时，采用jar的打包方式

* `SpringBoot` 的引导类是项目的入口，运行 `main` 方法就可以启动项目

  因为我们在 `pom.xml` 中配置了 `spring-boot-starter-web` 依赖，而该依赖通过前面的学习知道它依赖 `tomcat` ，所以运行 `main` 方法就可以使用 `tomcat` 启动咱们的工程。

  

#### 4.1.3  切换web服务器

​		现在我们启动工程使用的是 `tomcat` 服务器，那能不能不使用 `tomcat` 而使用 `jetty` 服务器，`jetty` 在我们 `maven` 高级时讲 `maven` 私服使用的服务器。而要切换 `web` 服务器就需要将默认的 `tomcat` 服务器给排除掉，怎么排除呢？使用 `exclusion` 标签

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion>
            <artifactId>spring-boot-starter-tomcat</artifactId>
            <groupId>org.springframework.boot</groupId>
        </exclusion>
    </exclusions>
</dependency>
```

​		现在我们运行引导类可以吗？运行一下试试，打印的日志信息如下

![image-20210918232512707](/assets/SSM.assets/image-20210918232512707.png)

​		程序直接停止了，为什么呢？那是因为排除了 `tomcat` 服务器，程序中就没有服务器了。所以此时不光要排除 `tomcat` 服务器，还要引入 `jetty` 服务器。在 `pom.xml` 中因为 `jetty` 的起步依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>
```

​		接下来再次运行引导类，在日志信息中就可以看到使用的是 `jetty` 服务器

![image-20210918232904623](/assets/SSM.assets/image-20210918232904623.png)

**小结：**

​		通过切换服务器，我们不难发现在使用 `SpringBoot` 换技术时只需要导入该技术的起步依赖即可。



### 4.2 配置文件

​		`SpringBoot` 提供了多种属性配置方式

* `application.properties`

  ```
  server.port=80
  ```

* `application.yml`

  ```yaml
  server:
  	port: 81
  ```

* `application.yaml`

  ```yaml
  server:
  	port: 82
  ```

> 注意：`SpringBoot` 程序的配置文件名必须是 `application` ，只是后缀名不同而已。
>
> 优先级：propertie > yml > yaml

==注意：在配合文件中如果没有提示，可以使用一下方式解决==

* 点击 `File` 选中 `Project Structure`

<img src="/assets/SSM.assets/image-20210917163557071.png" alt="image-20210917163557071" style="zoom:80%;">

* 弹出如下窗口，按图中标记红框进行选择

<img src="/assets/SSM.assets/image-20210917163736458.png" alt="image-20210917163736458" style="zoom:70%;">

* 通过上述操作，会弹出如下窗口

<img src="/assets/SSM.assets/image-20210917163818051.png" alt="image-20210917163818051" style="zoom:80%;">

* 点击上图的 `+` 号，弹出选择该模块的配置文件

<img src="/assets/SSM.assets/image-20210917163828518.png" alt="image-20210917163828518" style="zoom:80%;">

* 通过上述几步后，就可以看到如下界面。`properties` 类型的配合文件有一个，`ymal` 类型的配置文件有两个

<img src="/assets/SSM.assets/image-20210917163846243.png" alt="image-20210917163846243" style="zoom: 67%;">

#### 4.2.1 yaml

​		**YAML（YAML Ain't Markup Language），一种数据序列化格式。**这种格式的配置文件在近些年已经占有主导地位，那么这种配置文件和前期使用的配置文件是有一些优势的。

**优点：**

* 容易阅读

  `yaml` 类型的配置文件比 `xml` 类型的配置文件更容易阅读，结构更加清晰

* 容易与脚本语言交互

* 以数据为核心，重数据轻格式

> `yaml` 更注重数据，而 `xml` 更注重格式



**YAML 文件扩展名：**

* `.yml` (主流)
* `.yaml`

上面两种后缀名都可以，以后使用更多的还是 `yml` 的。



**语法规则**

* 大小写敏感

* 属性层级关系使用多行描述，每行结尾使用冒号结束

* 使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）

  空格的个数并不重要，只要保证同层级的左侧对齐即可。

* 属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）

* \# 表示注释

==核心规则：数据前面要加空格与冒号隔开==

数组数据在数据书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔，例如

```yaml
enterprise:
  name: itcast
  age: 16
  tel: 4006184000
  subject:
    - Java
    - 前端
    - 大数据
```



### 4.3 读配置文件

#### 4.3.1 使用@value

例如：

```yaml
lesson: SpringBoot

server:
  port: 80

enterprise:
  name: itcast
  age: 16
  tel: 4006184000
  subject:
    - Java
    - 前端
    - 大数据
```



```java
@RestController
public class BookController {
    
    @Value("${lesson}")
    private String lesson;
    @Value("${server.port}")
    private Integer port;
    @Value("${enterprise.subject[0]}")
    private String subject_00;

    @GetMapping("/{id}")
    public String getById(@PathVariable Integer id){
        System.out.println(lesson);
        System.out.println(port);
        System.out.println(subject_00);
        return "hello , spring boot!";
    }
}
```

​		

#### 4.3.2 使用Environment

​		上面方式读取到的数据特别零散，`SpringBoot` 还可以使用 `@Autowired` 注解注入 `Environment` 对象的方式读取数据。这种方式 `SpringBoot` 会将配置文件中**所有的数据**封装到 `Environment` 对象中，如果需要使用哪个数据只需要通过调用 `Environment` 对象的 `getProperty(String name)` 方法获取。具体代码如下：

```java
@RestController
public class BookController {
    
    @Autowired
    private Environment env;
    
    @GetMapping("/{id}")
    public String getById(@PathVariable Integer id){
        System.out.println(env.getProperty("lesson"));
        System.out.println(env.getProperty("enterprise.name"));
        System.out.println(env.getProperty("enterprise.subject[0]"));
        return "hello , spring boot!";
    }
}
```



#### 4.3.3 使用自定义对象

`SpringBoot` 还提供了将配置文件中的数据封装到我们自定义的实体类对象中的方式。具体操作如下：

1. 将实体类 `bean` 的创建交给 `Spring` 管理。

> 在类上添加 `@Component` 注解

2. 使用 `@ConfigurationProperties` 注解表示加载配置文件

> 在该注解中也可以使用 `prefix` 属性指定只加载指定前缀的数据

3. 在 `BookController` 中进行注入



具体代码如下：

`Enterprise` 实体类内容如下：

```java
@Component
@ConfigurationProperties(prefix = "enterprise")
public class Enterprise {
    private String name;
    private int age;
    private String tel;
    private String[] subject;
    //省略getter，setter，toString
}
```

`BookController` 内容如下：

```java
@RestController
@RequestMapping("/books")
public class BookController {
    
    @Autowired
    private Enterprise enterprise;

    @GetMapping("/{id}")
    public String getById(@PathVariable Integer id){
        System.out.println(enterprise.getName());
        System.out.println(enterprise.getAge());
        System.out.println(enterprise.getSubject());
        System.out.println(enterprise.getTel());
        System.out.println(enterprise.getSubject()[0]);
        return "hello , spring boot!";
    }
}
```

**注意：**

使用第三种方式，在实体类上有如下警告提示

<img src="/assets/SSM.assets/image-20210917180919390.png" alt="image-20210917180919390" style="zoom:70%;">

这个警告提示解决是在 `pom.xml` 中添加如下依赖即可

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>
```



### 4.4 多环境配置

#### 4.4.1 yml

```yaml
#设置启用的环境
spring:
  profiles:
    active: dev

---
#开发
spring:
  profiles: dev
server:
  port: 80
---
#生产
spring:
  profiles: pro
server:
  port: 81
---
#测试
spring:
  profiles: test
server:
  port: 82
---
```

**注意：**

在上面配置中给不同配置起名字的 `spring.profiles` 配置项已经过时。最新用来起名字的配置项是

```yaml
#开发
spring:
  config:
    activate:
      on-profile: dev
```



#### 4.4.2 properties

`properties` 类型的配置文件配置多环境需要**定义不同的配置文件**

* `application-dev.properties` 是开发环境的配置文件。我们在该文件中配置端口号为 `80`

  ```properties
  server.port=80
  ```

* `application-test.properties` 是测试环境的配置文件。我们在该文件中配置端口号为 `81`

  ```properties
  server.port=81
  ```

* `application-pro.properties` 是生产环境的配置文件。我们在该文件中配置端口号为 `82`

  ```properties
  server.port=82
  ```

**`SpringBoot` 只会默认加载名为 `application.properties` 的配置文件**，所以需要在 `application.properties` 配置文件中设置启用哪个配置文件，配置如下:

```properties
spring.profiles.active=pro
```



#### 4.4.3 命令行启动参数设置

​		使用 `SpringBoot` 开发的程序以后都是打成 `jar` 包，通过 `java -jar xxx.jar` 的方式启动服务的。那么就存在一个问题，如何切换环境呢？因为配置文件打到的jar包中了。

​		我们知道 `jar` 包其实就是一个压缩包，可以解压缩，然后修改配置，最后再打成jar包就可以了。

​		这种方式显然有点麻烦，而 `SpringBoot` 提供了在运行 `jar` 时设置开启指定的环境的方式，如下

```shell
java –jar xxx.jar –-spring.profiles.active=test
```

那么这种方式能不能临时修改端口号呢？也是可以的，可以通过如下方式

```shell
java –jar xxx.jar –-server.port=88
```

当然也可以同时设置多个配置，比如即指定启用哪个环境配置，又临时指定端口，如下

```shell
java –jar springboot.jar –-server.port=88 –-spring.profiles.active=test
```

大家进行测试后就会发现命令行设置的端口号优先级高（也就是使用的是命令行设置的端口号），配置的优先级其实 `SpringBoot` 官网已经进行了说明，参见 :

```
https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config
```

进入上面网站后会看到如下页面

![image-20210917193910191](/assets/SSM.assets/image-20210917193910191.png)

​		如果使用了多种方式配合同一个配置项，优先级高的生效。



### 4.5 配置文件优先级

​		有这样的场景，我们开发完毕后需要测试人员进行测试，由于测试环境和开发环境的很多配置都不相同，所以测试人员在运行我们的工程时需要临时修改很多配置，如下

```shell
java –jar springboot.jar –-spring.profiles.active=test --server.port=85 --server.servlet.context-path=/heima --server.tomcat.connection-timeout=-1 …… …… …… …… ……
```

针对这种情况，`SpringBoot` 定义了配置文件不同的放置的位置；而放在不同位置的优先级时不同的。

`SpringBoot` 中4级配置文件放置位置：

* 1级：classpath: application.yml 
* 2级：classpath: config/application.yml
* 3级：file: application.yml
* 4级：file: config/application.yml

> ==说明：==级别越高优先级越高



**代码演示**

**验证1级2级的优先级**

创建一个名为 `springboot_06_config_file` 的 `SpringBoot` 工程，目录结构如下

<img src="/assets/SSM.assets/image-20210917200241282.png" alt="image-20210917200241282" style="zoom:80%;">

在 `resources` 下创建一个名为 `config` 的目录，在该目录中创建 `application.yml` 配置文件，而在该配置文件中将端口号设置为 `81`，内容如下

```yaml
server:
  port: 81
```

而在 `resources` 下创建的 `application.yml` 配置文件中并将端口号设置为 `80`，内容如下

```yaml
server:
  port: 80
```

运行启动引导类，可以在控制台看到如下日志信息

![image-20210917200805389](/assets/SSM.assets/image-20210917200805389.png)

通过这个结果可以得出==类路径下的 `config` 下的配置文件优先于类路径下的配置文件。==



**验证2级和4级的优先级**

要验证4级，按照以下步骤完成

* 将工程打成 `jar` 包

  点击工程的 `package` 来打 `jar` 包

  <img src="/assets/SSM.assets/image-20210917201243721.png" alt="image-20210917201243721" style="zoom:80%;">

* 在硬盘上找到 `jar` 包所在位置

  <img src="/assets/SSM.assets/image-20210917201523669.png" alt="image-20210917201523669" style="zoom:70%;">

* 在 `jar` 包所在位置创建 `config` 文件夹，在该文件夹下创建 `application.yml` 配置文件，而在该配合文件中将端口号设置为 `82` 

* 在命令行使用以下命令运行程序

  ```shell
  java -jar springboot_06_config_file-0.0.1-SNAPSHOT.jar
  ```

  运行后日志信息如下

  ![image-20210917201922831](/assets/SSM.assets/image-20210917201922831.png)

  通过这个结果可以得出**file： `config` 下的配置文件优先于classpath下的配置文件。**

> ==注意：==
>
> SpringBoot 2.5.0版本存在一个bug，我们在使用这个版本时，需要在 `jar` 所在位置的 `config` 目录下创建一个任意名称的文件夹



### 4.6 整合MyBatis

**1. 添加依赖**

```xml
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>2.2.2</version>
        </dependency>

        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid</artifactId>
            <version>1.1.16</version>
        </dependency>
```

**2. 编写配置文件**

```yaml
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/student
    username: root
    password: 123456
```

**3. 写Mapper接口**

​		略

