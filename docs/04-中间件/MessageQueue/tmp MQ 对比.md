# MQ 对比

# 1. 核心差异

- **RabbitMQ** 像一个精密的**路由器**（侧重逻辑与即时响应）。
- **Kafka** 像一根巨大的**输油管**（侧重吞吐与流处理）。
- **RocketMQ** 像一个**金融级账本**（侧重业务稳定性、事务与 Java 生态）。

| **特性**   | **RabbitMQ**          | **RocketMQ**          | **Kafka**             |
| -------- | --------------------- | --------------------- | --------------------- |
| **开发语言** | Erlang (黑盒，难定制)       | **Java** (适合你，源码可控)   | Scala/Java            |
| **设计定位** | 高并发、低延迟、复杂路由          | 金融级高可靠、分布式事务          | 超高吞吐、日志收集、流计算         |
| **消息模式** | 智能 Broker，傻瓜 Consumer | 傻瓜 Broker，智能 Consumer | 傻瓜 Broker，智能 Consumer |
| **单机吞吐** | 万级 (~1-2w)            | 十万级 (~10w+)           | 百万级 (极限吞吐)            |
| **延迟**   | **微秒级** (极低)          | 毫秒级                   | 毫秒级                   |
| **可用性**  | 主从架构 (非强一致)           | 主从/Dledger (支持强一致)    | 分区副本机制 (强一致)          |
| **功能特色** | Exchange 灵活路由、优先队列    | **事务消息**、延时消息、重试      | 批处理、流式处理              |




| **特性维度**        | **Apache RocketMQ**           | **Apache Kafka**                   | **RabbitMQ**                             |
| --------------- | ----------------------------- | ---------------------------------- | ---------------------------------------- |
| **设计定位**        | 金融级在线业务、高并发交易                 | 大数据日志采集、高吞吐流处理                     | **传统企业级集成、复杂路由、低延迟通讯**                   |
| **单机 Topic 支持** | **万级 Topic**，吞吐量几乎不下降         | Topic 过多会导致随机 IO 剧增，性能下降           | **较弱**，大量 Queue 会占用高内存并导致性能骤降            |
| **消息存储结构**      | 所有 Topic 混写 CommitLog，**顺序写** | 每个 Partition 独立文件，多 Topic 时**随机写** | **内存为主**，消息堆积时分页写入磁盘 (索引+堆存储)            |
| **可靠性机制**       | 同步/异步刷盘、主从复制、Raft (DLedger)   | ISR 机制、异步刷盘                        | **强**，支持镜像队列 / Quorum Queues (Raft)      |
| **延迟消息**        | **支持**（4.x 固定级别，5.0 任意时间）     | 不支持（需依赖第三方或应用层实现）                  | **支持**（需安装插件或利用 TTL + 死信队列实现）            |
| **事务消息**        | **支持**（基于 2PC 与回查机制）          | 支持（主要用于流处理的 Exactly-Once）          | **支持**（AMQP 事务性能差，推荐用 Publisher Confirm） |
| **消费模型**        | Push / Pull / POP（5.0 引入）     | Pull                               | **Push** (主要，实时性高) / Pull (性能低，不推荐)      |

### 补充说明：为什么 RabbitMQ 在"存储结构"上这么不同？

- **RocketMQ / Kafka (日志流派):** 设计初衷就是**堆积**。数据落盘是第一位的，消费者读不读，数据都在磁盘上。
    
- **RabbitMQ (队列流派):** 设计初衷是**传递**。最好的状态是队列为空（消息一到就被消费掉）。如果消息大量堆积，RabbitMQ 性能会急剧下降，因为它需要把内存里的消息换页（Page Out）到磁盘，这会阻塞处理进程。


### 1. 核心区别：Kafka vs RabbitMQ

- **Kafka/RocketMQ 的 Topic:** 是一个 **“物理位置”**。你把消息发给 Topic A，消息就真的存在 Topic A 的文件里。
    
- **RabbitMQ 的 Topic:** 是一个 **“逻辑规则”**。你把消息发给交换机，交换机根据路由键（Routing Key）的规则（比如通配符匹配），决定把消息扔进哪个 **Queue（队列）** 里。消息最终是存在 Queue 里的。


在技术选型中，RabbitMQ 常与 Kafka、RocketMQ 和 Pulsar 进行对比。

### 8.1 RabbitMQ vs. Apache Kafka

这是最经典的对比，本质上是“智能管道”与“智能终端”的区别。

|**特性**|**RabbitMQ (Smart Broker)**|**Apache Kafka (Smart Client)**|
|---|---|---|
|**设计理念**|消息在代理端被处理、路由和删除。代理维护消费者状态。|消息作为日志持久化。消费者自行维护偏移量（Offset）。|
|**吞吐量**|单机万级到十万级 TPS。受限于复杂的路由和内存管理。|单机百万级 TPS。利用顺序写磁盘和零拷贝技术。|
|**延迟**|微秒级至毫秒级。适合实时交互。|毫秒级。受限于批量发送（Batching）和轮询（Polling）。|
|**消息顺序**|队列级别有序。但在死信重试或多消费者时难以保证全局有序。|分区（Partition）级别严格有序。|
|**适用场景**|复杂的业务路由、任务队列、即时响应、协议兼容性要求高。|大数据日志收集、流式处理、事件溯源、数据重放。|

### 8.2 RabbitMQ vs. RocketMQ

RocketMQ 源于阿里，设计上介于 RabbitMQ 和 Kafka 之间。

- **事务消息**：RocketMQ 原生支持 2PC 事务消息（半消息+回查机制），能够保证本地事务与消息发送的最终一致性。RabbitMQ 虽然支持事务（Tx），但性能极差，通常推荐使用 Publisher Confirms 替代 。
    
- **架构**：RocketMQ 去除了 Zookeeper 依赖（早期），使用 NameServer，架构轻量。RabbitMQ 依赖 Erlang 分布式，运维复杂度相对较高。


| **特性维度**   | **RabbitMQ (Quorum)** | **RocketMQ (Sync/DLedger)**      | **Kafka (Standard)**       |
| ---------- | --------------------- | -------------------------------- | -------------------------- |
| **一致性算法**  | **Raft** (强一致)        | **Raft** (DLedger) / 主从同步        | **ISR** (动态同步集合)           |
| **单机持久化**  | **WAL + Fsync** (批处理) | **Sync Flush** (强) / Async Flush | **OS Page Cache** (弱，依赖复制) |
| **数据重复**   | 极低 (Raft 保证)          | 可能 (At-Least-Once)               | 无 (幂等性开启时)                 |
| **事务支持**   | AMQP 事务 (极慢)          | **2PC 事务消息** (最终一致性)             | **流式事务** (Exactly-Once)    |
| **网络分区行为** | **CP** (暂停写入，保数据)     | **CP** (DLedger 模式)              | **可配置** (默认 CP，可降级为 AP)    |
| **消费模型**   | Push (预取控制)           | Pull (长轮询)                       | Pull (批量拉取)                |
| **最大优势**   | 复杂路由下的数据安全            | 业务与消息的事务一致性                      | 海量吞吐下的可配置可靠性               |