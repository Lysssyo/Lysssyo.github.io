# MQ 刷盘策略与复制策略横向对比

在分布式消息系统中，数据的可靠性由 **单机持久化（刷盘）** 与 **多机冗余（复制）** 共同决定。本篇通过横向对比 RabbitMQ、RocketMQ 与 Kafka，揭示其背后的设计哲学与性能权衡。

---

## 1. RabbitMQ：从异步路由到 Raft 强一致

RabbitMQ 的刷盘与复制策略与其“队列类型”深度绑定。

### 1.1 刷盘策略

- **经典队列 (Classic Queues)**：可以配置是否刷盘，如果配置了刷盘，本质是“异步刷盘”。依赖操作系统 Page Cache，即便配置了持久化，也是 Ack 后异步落盘，存在丢数风险。
- **仲裁队列 (Quorum Queues)**：强制 **同步刷盘 (WAL)**。遵循 Raft 协议，消息必须 fsync 写入 WAL 且多数派确认后才返回 Ack。
- **关键细节**：仲裁队列忽略 `delivery_mode=1` 的非持久化标志，强制保证数据安全。
- **参考**：[刷盘策略：经典队列 vs 仲裁队列](010%20-%20RabbitMQ%20深度剖析.md#3.2.4%20刷盘策略：经典队列%20vs%20仲裁队列)

### 1.2 复制策略

- **经典队列（镜像模式）**：阻塞式同步。采用链式或广播复制，节点加入时的全量同步会引发“惊群效应”导致服务停顿。
	- **参考**：[传统高可用：镜像队列的缺陷](010%20-%20RabbitMQ%20深度剖析.md#4.1%20传统高可用：镜像队列的缺陷)
- **仲裁队列**：基于 Raft 的多数派写入。
	- **关键细节**：仲裁队列中 **“ACK 也是一次写操作”**。消费者发回 ACK 必须作为状态变更写入 Raft 日志并同步至多数派，因此其 ACK 吞吐量天然低于经典队列。
	- **参考**：[仲裁队列复制流程](010%20-%20RabbitMQ%20深度剖析.md#3.2.3.2%20复制流程)

---

## 2. RocketMQ：三态演进下的灵活权衡

RocketMQ 的策略取决于其架构形态（传统主从、DLedger、Controller）。

### 2.1 刷盘策略

- **同步刷盘 (SYNC_FLUSH)**：强 fsync 模式，金融级一致性。
- **异步刷盘 (ASYNC_FLUSH)**：高性能模式，建议开启 `TransientStorePool`（堆外内存池）实现读写分离，规避 PageCache 锁竞争。
- **关键细节**：
    - **DLedger 模式**：官方强烈建议配置为 **异步刷盘**。因为 Raft 已保证多副本安全，若再开启同步刷盘会产生“网络 RTT + 磁盘 fsync”的 **双重连坐惩罚**。
    - **Controller 模式**：解耦了复制与刷盘，允许根据业务配置同步刷盘还是异步刷盘，同步刷盘下只有 Leader 会 `fsync`。
- **参考**：[3.3 刷盘策略 (Flush Policy) 深度解析](020%20-%20Apache%20RocketMQ%20深度剖析.md#3.3%20刷盘策略%20(Flush%20Policy)%20深度解析)

### 2.2 复制策略

- **传统主从**：依靠 `brokerRole` (SYNC/ASYNC_MASTER) 静态配置，无法自动选主。
- **DLedger (Raft)**：多数派写入机制。
    - **对比洞察**：RabbitMQ 仲裁队列追求“多数派刷盘”；RocketMQ DLedger 在异步刷盘下追求的是“多数派进内存（PageCache）”。
- **Controller 模式**：基于 **SyncStateSet (动态 ISR)** 的流同步。
    - **技术优势**：抛弃了重型的 Raft 日志封装，采用经过优化的 **HAService TCP 流同步**，性能远高于 DLedger。
- **参考**：[复制策略 (Replication Policy) 深度解析](020%20-%20Apache%20RocketMQ%20深度剖析.md#3.4%20复制策略%20(Replication%20Policy)%20深度解析)

---

## 3. Kafka：基于 PageCache 的自信哲学

Kafka 的设计颠覆了“单机刷盘”的传统逻辑。

### 3.1 刷盘策略

- **极致的 IO 优化**：Kafka **不主动调用 fsync**，完全依赖 OS 调度。
- **设计哲学**：**“多机内存冗余胜过单机磁盘冗余”**。通过 ISR 副本机制，Kafka 认为数据在多台机器的内存中比在单台机器的硬盘里更安全且快得多。
- **参考**：[极致的 IO 优化与内存管理](030%20-%20Apache%20Kafka%20深度剖析.md#3.4%20极致的%20IO%20优化与内存管理)

### 3.2 复制策略

- **ISR (In-Sync Replicas) 机制**：动态同步状态集合。
- **关键细节**：HW（高水位）控制消费者可见性，Leader Epoch 解决了 HW 更新滞后导致的数据截断丢失问题。RocketMQ 5.0 的 Controller 模式本质上是向这一机制的成熟度靠拢。
- **参考**：[生产端可靠性：Acks、ISR 与 幂等性](040%20-%20MQ%20可靠性机制剖析：RabbitMQ、RocketMQ%20与%20Kafka.md#5.1%20生产端可靠性：Acks%2C%20ISR%20与%20幂等性) 以及 [高可用与分布式协调架构演进](030%20-%20Apache%20Kafka%20深度剖析.md#4.%20高可用与分布式协调架构演进)

---

## 4. 总结：跨中间件的“可靠性坐标系”

| **维度** | **RabbitMQ (Quorum)** | **RocketMQ (DLedger)** | **RocketMQ (Controller)** | **Kafka (ISR)** |
| :--- | :--- | :--- | :--- | :--- |
| **一致性信仰** | **单机磁盘 fsync** | **多数派共识** | **动态 ISR + 灵活刷盘** | **多机内存冗余** |
| **同步成本** | 最高 (ACK is Write) | 中 (Raft Log 封装) | **较低 (TCP 流同步)** | **最低 (Zero-Copy)** |
| **选主逻辑** | Raft 自动选主 | Raft 自动选主 | Controller 智能调度 | Controller 智能调度 |
| **性能极限** | 较低 | 中 | 高 | 极高 |