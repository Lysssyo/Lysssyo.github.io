# 限流算法

本文档总结了分布式系统中常见的四种限流算法：固定/滑动窗口、漏桶、令牌桶以及 GCRA。

---

## 1. 计数器类算法 (Counter Based)

### 1.1 固定窗口 (Fixed Window)

最简单的限流算法。将时间划分为固定的窗口（如 1秒 1个窗口），每个窗口维护一个计数器。

*   **原理**: 
    *   `Key = "limit:10:00:01"`, `Value = count`。
    *   请求来时 `INCR(Key)`，若 `> Limit` 则拒绝。
*   **优点**: 实现极其简单 (Redis `INCR` + `EXPIRE`)，内存占用小。
*   **缺点**: **临界突发 (Critical Burst)** 问题。
    *   例如限制 100 QPS。
    *   在 `0.99秒` 来了 100 个请求（通过）。
    *   在 `1.01秒` 又来了 100 个请求（通过）。
    *   结果：在 `0.99~1.01` 这 **0.02秒** 瞬间，系统承受了 **200** 个请求，远超预期的平滑速率，可能压垮数据库。

### 1.2 滑动窗口 (Sliding Window Log)
为了解决固定窗口的临界问题，将窗口改为随时间平滑移动。

*   **原理**: 
    *   记录 **每一次** 请求的时间戳（通常使用 Redis ZSet）。
    *   请求来时，移除 `Now - WindowSize` 之前的记录。
    *   统计集合中剩余的记录数，若 `> Limit` 则拒绝。
*   **优点**: 精确控制，完全解决了临界突发问题，流量非常平滑。
*   **缺点**: **存储成本极高**。需要存储窗口内所有请求的时间戳。如果限流阈值是 10w QPS，Redis ZSet 就得存 10w 条数据，内存和带宽开销不可接受。

> [!TIP] `now` 是当前时间戳， `WindowSize` 是时间窗口大小（例如10s）

## 2. 桶类算法 (Bucket Based)

### 2.1 漏桶算法 (Leaky Bucket)

将请求视为水注入桶中，桶底以**固定速率**漏水（处理请求）。

*   **形象比喻**: 无论你灌水（请求）多快，水龙头（处理能力）永远是一滴一滴匀速流出。
*   **特点**: **强行平滑**。
    *   **不允许突发**。即使系统空闲了一整天，请求一来，也只能按规定的慢速处理。
*   **适用场景**: 保护下游极度脆弱的资源（如写入磁带机、老旧系统），绝对不能超过其处理能力上限。

### 2.2 令牌桶算法 (Token Bucket)

系统以固定速率往桶里放入“令牌”。请求来时，必须拿到令牌才能处理。

*   **形象比喻**: 
    *   每秒发 10 张消费券（令牌）进桶。桶满（Capacity）则丢弃令牌。
    *   如果一整天没人来，桶里就攒满了券（Burst Capacity）。
    *   突然来了一波人，可以把桶里的券一次性用光（**允许突发**）。
    *   券用光后，后续的人就得等新券发下来（退化为固定速率）。
*   **优点**: **支持突发 (Burst)**。允许在系统空闲后处理短时间的流量尖峰，对用户体验更友好。
*   **缺点**: 实现稍复杂，需要维护“令牌数”和“上次投放时间”。

**例如：**

- **限流规则**：每 1 秒产生 1 个配额（Rate = 1 r/s）。
- **突发能力**：最多允许积累 2 个配额（Burst = 2）。也就是说，空闲久了可以瞬间连发 3 个请求（2 个存货 + 1 个当前的）。

它维护两个状态：`tokens` (当前硬币数) 和 `last_time` (上次加币时间)。

**初始状态 (T=0s)**: 桶满了，`tokens = 2`, `last_time = 0`。

| **时间点**  | **事件**   | **动作逻辑**                                                               | **结果**                       |
| -------- | -------- | ---------------------------------------------------------------------- | ---------------------------- |
| **0.1s** | **请求 A** | 1. 距上次 0.1s，应补 0.1 个币 -> 此时 `tokens = 2` (满)。<br><br>2. 消耗 1 个币。       | **通过**<br><br>  <br>剩 1 个币   |
| **0.1s** | **请求 B** | 1. 距上次 0s，不补币。<br><br>2. 消耗 1 个币。                                      | **通过**<br><br>剩 0 个币 (连发成功)  |
| **0.1s** | **请求 C** | 1. 距上次 0s，不补币。<br><br>2. **币不够了(0)**。                                  | **拒绝**                       |
| **1.5s** | **请求 D** | 1. 距上次(0.1s)过了 1.4s，**补 1.4 个币** -> `tokens = 1.4`。<br><br>2. 消耗 1 个币。 | **通过**<br><br>  <br>剩 0.4 个币 |

---

## 3. GCRA 算法 (Generic Cell Rate Algorithm)

**GCRA** (Generic Cell Rate Algorithm) 。它本质上是 **漏桶算法的变体**，但在表现上实现了 **令牌桶的效果**（支持突发）。实际上，GCRA算法和令牌桶算法是**从两个不同维度解决同一个问题**。

### 3.1 核心原理：时间轴模型
GCRA 不存储“有多少个令牌”，而是存储 **“理论到达时间” (TAT, Theoretical Arrival Time)**。它把速率限制转化为时间间隔限制。

*   **关键参数**:
    *   `Emission Interval (T)`: 请求间隔。即处理一个请求需要的“理论耗时”。例如限流 60 QPM，则 `T = 1s`。
    *   `Delay Tolerance (Limit)`: 提前容忍度。这对应于令牌桶中的 **Burst (突发容量)**。允许你比理论时间“早到”多久。

### 3.2 判定逻辑

当一个请求在时间 `now` 到达时，假设QPM为60，Busrt为2.

**核心公式**：
- 请求间隔 `T = 1s`。
- 最大容忍提前量 `Limit = 2s` (对应 Burst = 2)。
- **更新逻辑**：`NewTAT = max(Now, OldTAT) + T`。
- **判断逻辑**：如果你来的时间 `Now`，比 `TAT - Limit` 还要早，说明你太急了，拒绝。

**例如：**

| **时间点**  | **事件**   | **动作逻辑 (T=1s, Limit=2s)**                                                                                                                              | **结果**                          |
| -------- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------- |
| **0.1s** | **请求 A** | 1. 预期时间 `TAT` 是 0s。<br><br>2. 计算新排期：`max(0.1, 0) + 1s = 1.1s`。<br>  <br>3. 检查：我 0.1s 来了，允许的最早时间是 `1.1 - 2 = -0.9s`。0.1 > -0.9，**不早**。                  | **通过**<br><br>TAT 更新为 **1.1s**  |
| **0.1s** | **请求 B** | 1. 预期时间 `TAT` 是 1.1s。<br><br>2. 计算新排期：`max(0.1, 1.1) + 1s = 2.1s`。<br><br>3. 检查：我 0.1s 来了，允许的最早时间是 `2.1 - 2 = 0.1s`。0.1 >= 0.1，**踩线通过**。               | **通过**<br><br>TAT 更新为 **2.1s**  |
| **0.1s** | **请求 C** | 1. 预期时间 `TAT` 是 2.1s。<br><br>2. 计算新排期：`max(0.1, 2.1) + 1s = 3.1s`。<br><br>3. 检查：我 0.1s 来了，允许的最早时间是 `3.1 - 2 = 1.1s`。<br><br>4. **0.1 < 1.1**，**来太早了**！ | **拒绝**<br><br>  <br>TAT 保持 2.1s |
| **1.5s** | **请求 D** | 1. 预期时间 `TAT` 是 2.1s。<br><br>2. 计算新排期：`max(1.5, 2.1) + 1s = 3.1s`。<br><br>3. 检查：我 1.5s 来了，允许的最早时间是 `3.1 - 2 = 1.1s`。<br><br>4. 1.5 > 1.1，**不早**。       | **通过**<br><br>TAT 更新为 **3.1s**  |

### 3.3 GCRA 的优势
*   **Redis 友好**: 只需要在 Redis 中存储 **一个数值** (Key 对应的 TAT 时间戳)，空间复杂度 O(1)。
*   **原子性**: 可以通过一段非常简短的 Lua 脚本完成读取、判断、更新，天然支持分布式并发安全。
*   **高性能**: 无需后台线程（惰性计算），无临界突发问题，且支持突发。


