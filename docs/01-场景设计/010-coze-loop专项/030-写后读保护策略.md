这个工程在面对主从延迟时，采用了一种**“基于 Redis 的短期写标记 (Write Flag) + 读时强制路由 (Route-to-Master)”** 的策略。

这是一种在高性能和数据一致性之间做权衡的经典方案。

**核心策略：写后读保护 (Read-Your-Own-Writes)**

该策略的核心思想是：如果你（或系统）刚刚修改了某些数据，那么当你紧接着去读取这些数据时，系统会强制让你去主库读，以确保你读到的是最新的。而对于其他没有修改的数据，则继续从从库读，以分担主库压力。

```go
type ILatestWriteTracker interface {
	SetWriteFlag(ctx context.Context, resourceType ResourceType, resourceID int64, opts ...SetWriteFlagOpt)
	CheckWriteFlagByID(ctx context.Context, resourceType ResourceType, id int64) bool
	CheckWriteFlagBySearchParam(ctx context.Context, resourceType ResourceType, searchParam string) bool
}
```

1. 写入时 (Write Path) - 打标记

```go
// 调用示例
// ResourceTypeDataset ResourceType = "dataset"
d.writeTracker.SetWriteFlag(ctx, platestwrite.ResourceTypeDataset, dataset.ID, platestwrite.SetWithSearchParam(strconv.FormatInt(dataset.SpaceID, 10)))

// SetWriteFlag 记录实体的写操作
func (t *LatestWriteTracker) SetWriteFlag(ctx context.Context, resourceType ResourceType, resourceID int64, opts ...SetWriteFlagOpt) {
	opt := &setWriteFlagOpt{ttl: 5 * time.Second}
	for _, o := range opts {
		o(opt)
	}
	resource := &resourceInfo{
		resourceType: resourceType,
		id:           resourceID,
	}
	t.setWriteFlag(ctx, resource, false, opt)
	if opt.searchParam != "" {
		resource.searchParam = opt.searchParam
		t.setWriteFlag(ctx, resource, true, opt)
	}
}

func (t *LatestWriteTracker) setWriteFlag(ctx context.Context, resource *resourceInfo, isSearch bool, opt *setWriteFlagOpt) {
	if resource == nil {
		return
	}
	key := getWriteFlagKey(resource, isSearch)
	cli := t.redisCli
	if err := cli.Set(ctx, key, 1, opt.ttl).Err(); err != nil {
		// 写入失败不影响主流程
		logs.CtxWarn(ctx, "set latest write flag failed, key=%s", key)
	}
}
```

> 打标记有可能会打两种标记。因为搜索时可能点搜也有可能搜出一个list。例如，当我写完一个Dataset后要去读它的时候，我可能会直接去`/getDatasetByDatasetId`，也有可能去`/getDatasetList`。不管是哪种，我都要去查主库。

- 时机: 当执行 INSERT, UPDATE, DELETE 等写操作成功后。
- 动作: 立即调用 writeTracker.SetWriteFlag(…)。
- 标记内容:
    - Resource ID Key: 标记具体的资源 ID (如 dataset:1001) 被修改了。
    - Search Param Key: 标记相关的搜索维度 (如 space:888) 有变动。
- 存储: 这个标记存储在 Redis 中。
- 生命周期: 设置一个较短的过期时间 (TTL)（例如 1-3 秒，略大于预估的主从同步延迟时间）。这意味着系统认为 3秒后，从库应该已经追上主库了。

1. 读取时 (Read Path) - 查标记

- 时机: 当执行 SELECT 操作前（例如 GetDataset, ListDatasets）。
- 动作:
    - 点查 (`Get`): 调用 writeTracker.CheckWriteFlagByID(id)。检查该 ID 在 Redis 里是否有标记。
    - 列表查 (`List`): 调用 writeTracker.CheckWriteFlagBySearchParam(spaceID)。检查该搜索维度在 Redis 里是否有标记。
- 决策:
    - 有标记 (Hit): 说明数据“很可能”还没同步到从库。策略：强制路由到主库 (`db.WithMaster()`)。
    - 无标记 (Miss): 说明数据近期无变动，或变动已过期（认为从库已同步）。策略：默认路由到从库。

方案优缺点分析

- 优点:
    - 精准: 只针对刚修改的数据走主库，最大限度保护了主库性能。
    - 低侵入: 逻辑封装在 DAO 层，对上层业务透明。
    - 灵活: 支持按 ID 和按搜索条件两种粒度。
- 缺点/风险:
    - Redis 依赖: 如果 Redis 挂了，这套机制失效，可能读到旧数据（但在该工程中可能做了降级处理，比如 Redis挂了全走主库或全走从库，看具体实现）。
    - 竞态条件: 理论上在“写 DB”和“写Redis”之间极短的毫秒级内，如果并发读请求进来，仍可能读到旧数据。但对于大多数业务场景，这是可接受的。
    - TTL 预估: TTL 设置得太短，可能从库还没追上，标记就没了（读到旧数据）；TTL太长，主库压力会变大。需要根据实际的主从延迟监控来调整。