# 大模型调用结果解析策略

大模型（LLM）的输出往往是不稳定的。模型可能会返回不规范的 JSON、包含多余的“废话”（如 Markdown 代码块标记），或者完全自创格式。

为了提高系统的鲁棒性，CozeLoop 在 `EvaluatorSourcePromptServiceImpl` 中设计了一套 **“漏斗式” (Funnel)** 的解析降级策略。

**核心文件**：`backend/modules/evaluation/domain/service/evaluator_source_prompt_impl.go`

---

## 核心流程：`parseContentOutput`

系统按照 **从严到宽** 的优先级顺序尝试 4 种解析策略，只要有一种成功即返回。

```go
func parseContentOutput(ctx context.Context, evaluatorVersion *entity.PromptEvaluatorVersion, replyItem *entity.ReplyItem, output *entity.EvaluatorOutputData) error {
    content := gptr.Indirect(replyItem.Content)

    // 按优先级顺序执行解析策略
    strategies := []func(context.Context, string, *entity.EvaluatorOutputData) (bool, error){
        parseDirectJSON,         // 策略1：直接解析完整JSON
        parseRepairedJSON,       // 策略2：修复后解析完整JSON
        parseRegexExtractedJSON, // 策略3：正则提取JSON片段并解析
        parseScoreWithRegex,     // 策略4：正则暴力提取字段
    }

    for _, strategy := range strategies {
        success, err := strategy(ctx, content, output)
        if success { return nil }
    }

    return errorx.NewByCode(errno.InvalidOutputFromModelCode, ...)
}
```

---

## 策略详解

### 1. 策略一：直接 JSON 解析 (`parseDirectJSON`)

*   **机制**：直接使用高性能 JSON 库 (`sonic`) 进行反序列化。
*   **适用场景**：模型输出完美，格式标准。
*   **代码**：
    ```go
    if err := sonic.Unmarshal(b, &outputMsg); err == nil {
        // 校验必须包含 reason 字段
        if outputMsg.Reason != "" { ... return true, nil }
    }
    ```

### 2. 策略二：修复后 JSON 解析 (`parseRepairedJSON`)

*   **机制**：使用 `jsonrepair` 库先对文本进行修复，再解析。
*   **适用场景**：模型返回的 JSON 有轻微语法错误。
    *   键名未加引号：`{score: 1}`
    *   尾部多余逗号：`[1, 2,]`
    *   使用单引号：`{'score': 1}`
*   **代码**：
    ```go
    repairedContent, repairErr := jsonrepair.JSONRepair(content)
    if repairErr == nil {
        if err := sonic.Unmarshal([]byte(repairedContent), &outputMsg); err == nil { ... }
    }
    ```

### 3. 策略三：正则提取 JSON 片段 (`parseRegexExtractedJSON`)

*   **机制**：使用正则表达式从文本中提取看起来像 JSON 对象 `{...}` 的片段，然后对片段分别尝试“直接解析”和“修复后解析”。
*   **适用场景**：模型是个“话痨”，返回了 Markdown 标记或解释性文字。

	例子：

	``` 
	Here is the result: 
	```json {"score": 1} ``` 
	Hope it helps!
	```
*   **代码**：
    ```go
    // jsonRe 是一个复杂的正则，用于匹配 JSON 对象结构
    all := jsonRe.FindAll(b, -1)
    for _, bb := range all {
        // 1. 尝试直接解析片段
        if err := sonic.Unmarshal(bb, &outputMsg); err == nil { ... }
        
        // 2. 尝试修复片段后解析
        repairedFragment, _ := jsonrepair.JSONRepair(string(bb))
        if err := sonic.Unmarshal([]byte(repairedFragment), &outputMsg); err == nil { ... }
    }
    ```

### 4. 策略四：正则暴力提取字段 (`parseScoreWithRegex`)

*   **机制**：放弃将整体解析为对象，直接用正则扫描 `score` 和 `reason` 关键词。
*   **适用场景**：JSON 结构彻底崩坏，或者模型使用了非 JSON 格式（如 `Key: Value`）。
    *   例子：`Score: 5, Reason: "Excellent"`
*   **兜底逻辑**：
    *   **Score**: 必须提取到数字。
    *   **Reason**: 尝试提取 `"reason": "..."` 内容。**如果提取失败，则将整个 LLM 返回的原始内容作为 Reason**，以保留调试信息。
*   **代码**：
    ```go
    scoreRegex := regexp.MustCompile(`(?i)score[^0-9]*([0-9]+(?:\.[0-9]+)?)`)
    // ... 提取 Score ...
    
    // 尝试提取 Reason
    reasonMatches := reasonRegex.FindStringSubmatch(content)
    if len(reasonMatches) > 1 {
        output.EvaluatorResult.Reasoning = reasonMatches[1]
    } else {
        // 【兜底】无法提取 Reason 字段，使用完整输出作为 Reason
        output.EvaluatorResult.Reasoning = content 
    }
    ```