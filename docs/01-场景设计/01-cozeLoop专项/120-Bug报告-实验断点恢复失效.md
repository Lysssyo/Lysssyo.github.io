# FailRetry Mode实验断点恢复机制失效

## 1. 摘要

在实验运行模式为 **FailRetry (失败重试)** 时，系统旨在通过加载上一次运行的历史结果，跳过已成功的评估步骤。

然而，由于 **领域服务层 (Domain Service)** 中的一处数据映射错误，导致历史结果的 ID 引用失效。该错误数据被持久化到运行日志表 (`expt_turn_result_run_log`) 中，进而导致 Worker 在执行阶段无法查询到对应的评估记录 (`evaluator_record`)。

此外，即使数据源修复，Worker 内部的上下文缓存机制存在 Key 不一致的逻辑缺陷，导致无法命中缓存。

最终后果是：**断点恢复机制完全失效，所有评估器（包括已成功的）都会被强制重新执行。**

---

## 2. 缺陷一：历史结果 ID 映射错误 (Root Cause)

### 2.1 方法背景与职责
*   **方法**: `GetExptItemTurnResults`
*   **位置**: `backend/modules/evaluation/domain/service/expt_result_impl.go`
*   **调用方**: `ExptRecordEvalModeFailRetry.PreEval` (位于 `expt_run_item_event_impl.go`)，在 FailRetry 模式初始化阶段被调用。
*   **业务目标**: 从数据库中拉取该 Item 上一次运行的详细结果（Turn Results）。这些结果将被转换为 `RunLog` 存入 `expt_turn_result_run_log` 表，作为 Worker 执行时的“历史记忆”。

### 2.2 方法签名与数据结构
*   **入参**: `exptID`, `itemID` (锁定具体实验和数据项)
*   **出参**: `[]*entity.ExptTurnResult`
    *   该结构体包含一个关键字段 `EvaluatorResults` (类型: `*entity.EvaluatorResults`)。
    *   其内部包含一个 Map: `EvalVerIDToResID map[int64]int64` (预期 Key: 评估器版本ID ，Value: 评估记录ID)。

### 2.3 缺陷分析
在组装 `EvaluatorResults` Map 时，代码错误地将 **EvaluatorVersionID** 作为 Value 赋给了 Map，而本该赋值的是 **EvaluatorResultID**。

**错误代码片段**:
```go
// backend/modules/evaluation/domain/service/expt_result_impl.go : L117

// refs 是从中间表 expt_turn_evaluator_result_ref 查出的记录
// 包含: {ExptTurnResultID, EvaluatorVersionID, EvaluatorResultID}
for _, ref := range refs {
    // ...
    // [CRITICAL BUG]
    // 预期: Value = ref.EvaluatorResultID (指向 evaluator_record 表的主键，例如 748392...)
    // 实际: Value = ref.EvaluatorVersionID (评估器配置的 ID，例如 1001)
    turnEvaluatorVerIDToResultID[ref.ExptTurnResultID][ref.EvaluatorVersionID] = ref.EvaluatorVersionID 
}
```

### 2.4 下游连锁反应 (后果详解)
该错误会像多米诺骨牌一样引发一连串故障：

1.  **持久化阶段 (PreEval)**: 
    *   `PreEval` 方法调用 `ToRunLogDO()`，将这个错误的 Map `{VerID: VerID}` 序列化为 JSON。
    *   该 JSON 被存入 `expt_turn_result_run_log` 表的 `evaluator_result_ids` 字段。
    *   **数据库现状**: `{"EvalVerIDToResID":{"1001":1001}}` (错误，指向了 VersionID)
    *   **数据库预期**: `{"EvalVerIDToResID":{"1001":74839201}}` (正确，指向了 RecordID)

2.  **Worker 加载阶段 (buildExptTurnEvalCtx)**: 
    *   Worker ( `ExptItemEvalCtxExecutor` ) 启动时，读取 Log 并解析出 `{1001: 1001}`。
    *   调用 `evaluatorRecordService.BatchGetEvaluatorRecord(ids=[1001])`。
    *   **失败**: 系统尝试在 `evaluator_record` 表中查找 `ID=1001` 的记录。由于 1001 是 VersionID 而非 RecordID，查询结果为空。

3.  **执行判定阶段 (CallEvaluators)**: 
    *   Worker 发现内存中没有加载到任何历史记录。
    *   判定逻辑 `if existResult != nil` 失败。
    *   **结果**: Worker 认为该评估器从未运行过，发起新的 RPC 调用，造成重复扣费。

---

## 3. 缺陷二：Worker 上下文缓存 Key 不匹配

### 3.1 问题描述
即使修复了缺陷一，Worker 在其核心执行流程中，因为内部一个关键 Map 的 **读写 Key 不一致**，导致**缓存机制依然失效**。

### 3.2 关键对象与变量
*   **执行上下文 (Worker Context)**: `etec` (类型: `*entity.ExptTurnEvalCtx`)
*   **缓存 Map 变量**: `etec.ExptTurnRunResult.EvaluatorResults` (类型: `map[int64]*entity.EvaluatorRecord`)
    *   **职责**: 在 Worker 的内存上下文中缓存已加载的评估记录，供后续步骤快速查找，避免重复调用。

### 3.3 逻辑冲突分析

#### **写入方：`buildExptTurnEvalCtx` 方法**
*   **位置**: `backend/modules/evaluation/domain/service/expt_run_item_impl.go`
*   **调用时机**: 在 Worker (`ExptItemEvalCtxExecutor`) 开始处理一个 Turn 之前，负责**构建该 Turn 的执行上下文** (`etec`)，包括从数据库加载历史数据。
*   **行为**: 当从数据库成功查到 `evaluatorRecords` 后，它会构建 `EvaluatorResults` Map。
*   **错误逻辑**:
    ```go
    // backend/modules/evaluation/domain/service/expt_run_item_impl.go
    // ...
    recordMap := make(map[int64]*entity.EvaluatorRecord)
    for _, record := range evaluatorRecords {
        // 使用 record.ID (RecordID) 作为 Map 的 Key
        recordMap[record.ID] = record 
    }
    // 这个错误的 Map 被赋给了 Worker 的上下文
    etec.ExptTurnRunResult.EvaluatorResults = recordMap
    ```
*   **结果**: Worker 内存中的 Map 结构为 `{74839201: RecordObject}` (Key 是 RecordID)。

#### **读取方：`CallEvaluators` 方法**
*   **位置**: `backend/modules/evaluation/domain/service/expt_run_item_turn_impl.go`
*   **调用时机**: 在 Worker 完成对大模型的调用后，准备**逐个执行评估器**时。
*   **行为**: 在执行每个评估器之前，它会检查缓存，判断是否需要跳过。
*   **错误逻辑**:
    ```go
    // backend/modules/evaluation/domain/service/expt_run_item_turn_impl.go
    for _, evaluatorVersion := range expt.Evaluators {
        // [读取 Map]
        // 这里调用 GetEvaluatorRecord，并传入了 EvaluatorVersionID (例如 1001)
        existResult := etec.ExptTurnRunResult.GetEvaluatorRecord(evaluatorVersion.GetEvaluatorVersionID())
        
        // [判定]
        if existResult != nil && existResult.Status == entity.EvaluatorRunStatusSuccess {
            continue // 跳过
        }
        // ... 加入待执行列表 ...
    }
    ```
    `GetEvaluatorRecord` 的底层实现是 `return e.EvaluatorResults[evaluatorVersionID]`。

### 3.4 后果：缓存永远无法命中
这是一个典型的 **Key Mismatch (键不匹配)**，导致 `if` 判断永远为 `false`：

1.  `CallEvaluators` 循环到第一个评估器（VersionID=1001）。
2.  调用 `GetEvaluatorRecord(1001)`。
3.  该方法尝试在 `etec.ExptTurnRunResult.EvaluatorResults` 中查找 `Map[1001]`。
4.  但 `EvaluatorResults` 内部存的是 `Map[74839201] = Record`。
5.  查找失败，返回 `nil`。
6.  `existResult != nil` 判断为 `false`。
7.  **最终后果**: Worker 认为缓存不存在，将该评估器加入 `pendingEvaluatorVersionIDs` 列表，**重新执行一遍**。

---

## 4. 修复方案

### 修复缺陷一 (数据源头)
修改 `backend/modules/evaluation/domain/service/expt_result_impl.go`：
```go
// Fix: 将赋值源从 EvaluatorVersionID 修正为 EvaluatorResultID
turnEvaluatorVerIDToResultID[ref.ExptTurnResultID][ref.EvaluatorVersionID] = ref.EvaluatorResultID
```

### 修复缺陷二 (Worker缓存)
修改 `backend/modules/evaluation/domain/service/expt_run_item_impl.go`：
```go
// Fix: 使用 EvaluatorVersionID 作为 Key 构建 Map，与读取逻辑对齐
recordMap[record.EvaluatorVersionID] = record
```

