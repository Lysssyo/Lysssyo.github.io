# 实验详情读取与降级机制

> 基于 `backend/modules/evaluation/domain/service/expt_result_impl.go` 源码分析。

## 1. 核心架构模式：索引在 CK，详情在 MySQL

实验详情页（列表页）采用了 **"OLAP 筛选 + OLTP 详情"** 的混合读取模式。

> [!NOTE]
> - OLAP 筛选 (Online Analytical Processing)
> 	- **负责的事**：在海量数据（亿级、千亿级）中，通过复杂的条件找人/找物。
> 	- **特点**：列式存储，扫描速度极快，但不支持高并发的细微修改。
> - OLTP 详情 (Online Transaction Processing)
> 	- **负责的事**：根据确定的 ID，快速拿到这个实体的全部详细信息。
> 	- **特点**：行式存储，擅长随机读写（点查），能支撑极高的并发（QPS）。

*   **ClickHouse (`expt_turn_result_filter`)**: 充当**高性能二级索引**。负责处理复杂的筛选条件（如 `score > 0.8`）、关键字搜索（`LIKE %text%`）和排序。它只返回符合条件的 **`ItemID`** 列表。
*   **MySQL (`expt_turn_result`, `eval_target_record` 等)**: 充当**数据源 (Source of Truth)**。负责根据 `ItemID` 提供完整的实验数据、长文本内容、评估原因等。

---

## 2. 读取流程拆解

系统根据用户请求是否包含“高级筛选条件”(`UseAccelerator` / `HasFilters`)，自动分流为两条路径。

### 路径 A：普通分页查询 (Normal Pagination)

**场景**: 用户直接打开列表页，或仅进行简单翻页，未输入任何搜索/筛选条件。

*   **流程**: **MySQL 选人 -> MySQL 拿引用 -> 详情组装**。
*   **代码入口**: `ListTurnResult` 中的 `else` 分支。
*   **步骤**:
    1.  **Step 1 (MySQL - 选人)**: 查 `expt_item_result` 表。
        *   **SQL**: `SELECT item_id FROM expt_item_result WHERE expt_id = ? ORDER BY item_idx LIMIT 20 OFFSET 0`
        *   **作用**: 确定当前页的 **Item 范围和顺序**。
    2.  **Step 2 (MySQL - 拿引用)**: 查 `expt_turn_result` 表。
        *   **SQL**: `SELECT * FROM expt_turn_result WHERE item_id IN (...)`
        *   **作用**: 拿到这些 Item 对应的 **内容和评分的 ID 指针**。
    3.  **Step 3 (MySQL - 填肉)**: 交给 `PayloadBuilder`。
        *   **作用**: 并发去 `eval_target_record` 等表查出真正的文字和分数。

**总结路径**：`MySQL.ListItemResultsByExptID` (选ID) -> `MySQL.ListTurnResultByItemIDs` (拿引用) -> `PayloadBuilder` (填详情)

### 路径 B：高级筛选查询 (Filtered Query)
**场景**: 用户搜索了关键字（如“北京”），或筛选了分数（如“评估器A > 0.5”）。

*   **流程**: **ClickHouse 筛选 -> MySQL 拿引用 -> 详情组装**。
*   **代码入口**: `ListTurnResult` 中的 `if param.UseAccelerator` 分支。
*   **步骤**:
    1.  **Step 1 (CK - 选人/Who matches?)**
        *   调用 `exptTurnResultFilterRepo.QueryItemIDStates`。
        *   **SQL 逻辑**:
            ```sql
            SELECT item_id FROM expt_turn_result_filter FINAL
            WHERE expt_id = ? AND evaluator_score['keyA'] > 0.5
            ORDER BY item_idx LIMIT 20;
            ```
        *   **结果**: 返回一组符合条件的 `ItemID` 列表 (e.g., `[101, 105]`)。

    2.  **Step 2 (MySQL - 拿引用/What details?)**
        *   拿着 CK 返回的 ID 列表，调用 `ExptTurnResultRepo.ListTurnResultByItemIDs`。
        *   **SQL 逻辑**:
            ```sql
            SELECT * FROM expt_turn_result 
            WHERE item_id IN (101, 105);
            ```
    3.  **Step 3 (MySQL - 填肉)**: 交给 `PayloadBuilder`。
        *   **作用**: 并发去 `eval_target_record` 等表查出真正的文字和分数。

**总结路径**：`CK.QueryItemIDStates` (选ID) -> `MySQL.ListTurnResultByItemIDs` (拿引用) -> `PayloadBuilder` (填详情)

---

## 3. 详情组装通用逻辑 (PayloadBuilder)

无论是路径 A 还是路径 B，拿到基础的 `TurnResult` 后，都会殊途同归，进入 `PayloadBuilder.BuildItemResults` 进行内存组装。这一步负责“并发拉取”所有关联数据。

| 数据项 | 来源表 (MySQL) | 获取方式 |
| :--- | :--- | :--- |
| **模型回答 (Answer)** | `eval_target_record` | 通过 `turn_result.target_result_id` 关联查询。 |
| **评估分数 (Score)** | `evaluator_record` | 通过 `expt_turn_evaluator_result_ref` 关联查询 `score` 字段。 |
| **评估原因 (Reason)** | `evaluator_record` | 同上，查询 `reasoning` 字段。 |
| **数据集 (Input)** | `evaluation_set_item` | 通过 `item_id` 关联查询。 |
| **人工标注** | `annotate_record` | 通过 `ref` 表关联查询。 |

> **注意**: 详情数据**不**从 ClickHouse 读取，ClickHouse 仅用于加速筛选。

---

## 4. 优雅地失败 (Graceful Failure)

当 ClickHouse 发生故障（宕机、超时）时，系统实现了一种“保护性降级”策略，在代码中通过 `errOccur` 标志位控制。

**代码逻辑**:
```go
// backend/modules/evaluation/domain/service/expt_result_impl.go

if !errOccur {
    // 尝试查 CK
    itemID2ItemRunState, total, err = e.exptTurnResultFilterRepo.QueryItemIDStates(...)
    if err != nil {
        // 【CK 挂了】
        logs.CtxError(ctx, "QueryItemIDStates failed: %v", err)
        errOccur = true // 标记错误
        // itemID2ItemRunState 为空
    }
}

// ... 后续逻辑 ...

// 带着空的 itemIDs 去查 MySQL
turnResultDAOs, ... = e.ExptTurnResultRepo.ListTurnResultByItemIDs(..., itemIDs, ...)
```

**行为分析**:
1.  **非全量降级**: CK 挂了之后，系统**没有**自动切换回 MySQL 全量扫描（即没有移除 `WHERE IN (ids)` 条件）。
    *   *原因*: MySQL 全量处理复杂筛选（如 JSON 字段检索）性能极差，可能导致主库雪崩。
2.  **结果**: `ListTurnResultByItemIDs` 接收到空的 ID 列表，执行 `WHERE item_id IN (NULL)`，返回**空结果集**。
3.  **用户感知**: 筛选请求不报错（无 500 Error），但列表显示“暂无数据”。

**总结**: 这是一种**“牺牲可用性以保护稳定性”**的策略。系统选择让筛选功能暂时失效（返回空），而不是冒险去拖垮 MySQL 主库。
