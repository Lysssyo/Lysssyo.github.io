# 限流算法

本文档总结了分布式系统中常见的四种限流算法：固定/滑动窗口、漏桶、令牌桶以及 GCRA。

---

## 1. 计数器类算法 (Counter Based)

### 1.1 固定窗口 (Fixed Window)

最简单的限流算法。将时间划分为固定的窗口（如 1秒 1个窗口），每个窗口维护一个计数器。

*   **原理**: 
    *   `Key = "limit:10:00:01"`, `Value = count`。
    *   请求来时 `INCR(Key)`，若 `> Limit` 则拒绝。
*   **优点**: 实现极其简单 (Redis `INCR` + `EXPIRE`)，内存占用小。
*   **缺点**: **临界突发 (Critical Burst)** 问题。
    *   例如限制 100 QPS。
    *   在 `0.99秒` 来了 100 个请求（通过）。
    *   在 `1.01秒` 又来了 100 个请求（通过）。
    *   结果：在 `0.99~1.01` 这 **0.02秒** 瞬间，系统承受了 **200** 个请求，远超预期的平滑速率，可能压垮数据库。

### 1.2 滑动窗口 (Sliding Window Log)
为了解决固定窗口的临界问题，将窗口改为随时间平滑移动。

*   **原理**: 
    *   记录 **每一次** 请求的时间戳（通常使用 Redis ZSet）。
    *   请求来时，移除 `Now - WindowSize` 之前的记录。
    *   统计集合中剩余的记录数，若 `> Limit` 则拒绝。
*   **优点**: 精确控制，完全解决了临界突发问题，流量非常平滑。
*   **缺点**: **存储成本极高**。需要存储窗口内所有请求的时间戳。如果限流阈值是 10w QPS，Redis ZSet 就得存 10w 条数据，内存和带宽开销不可接受。

> [!TIP] `now` 是当前时间戳， `WindowSize` 是时间窗口大小（例如10s）

## 2. 桶类算法 (Bucket Based)

### 2.1 漏桶算法 (Leaky Bucket)
将请求视为水注入桶中，桶底以**固定速率**漏水（处理请求）。

*   **形象比喻**: 无论你灌水（请求）多快，水龙头（处理能力）永远是一滴一滴匀速流出。
*   **特点**: **强行平滑**。
    *   **不允许突发**。即使系统空闲了一整天，请求一来，也只能按规定的慢速处理。
*   **适用场景**: 保护下游极度脆弱的资源（如写入磁带机、老旧系统），绝对不能超过其处理能力上限。

### 2.2 令牌桶算法 (Token Bucket)
系统以固定速率往桶里放入“令牌”。请求来时，必须拿到令牌才能处理。

*   **形象比喻**: 
    *   每秒发 10 张消费券（令牌）进桶。桶满（Capacity）则丢弃令牌。
    *   如果一整天没人来，桶里就攒满了券（Burst Capacity）。
    *   突然来了一波人，可以把桶里的券一次性用光（**允许突发**）。
    *   券用光后，后续的人就得等新券发下来（退化为固定速率）。
*   **优点**: **支持突发 (Burst)**。允许在系统空闲后处理短时间的流量尖峰，对用户体验更友好。
*   **缺点**: 实现稍复杂，需要维护“令牌数”和“上次投放时间”。

---

## 3. GCRA 算法 (Generic Cell Rate Algorithm)

**GCRA** (Generic Cell Rate Algorithm) 。它本质上是 **漏桶算法的变体**，但在表现上实现了 **令牌桶的效果**（支持突发）。

### 3.1 核心原理：时间轴模型
GCRA 不存储“有多少个令牌”，而是存储 **“理论到达时间” (TAT, Theoretical Arrival Time)**。它把速率限制转化为时间间隔限制。

*   **关键参数**:
    *   `Emission Interval (T)`: 发射间隔。即处理一个请求需要的“理论耗时”。例如限流 10 QPS，则 `T = 100ms`。
    *   `Delay Tolerance (τ)`: 延迟容忍度。这对应于令牌桶中的 **Burst (突发容量)**。允许你比理论时间“早到”多久。

### 3.2 判定逻辑
当一个请求在时间 `t` 到达时：

1.  **计算 TAT**: 系统记录的“下一次允许请求的最早时间”。
2.  **比较**:
    *   **正常到达 (`t >= TAT`)**: 请求发生得很晚，系统已冷却。
        *   允许通过。
        *   更新 `TAT = t + T`。
    *   **提前到达 (`t < TAT`)**: 请求来早了。
        *   **允许突发**: 如果 `TAT - t <= τ` (没超过容忍度)，允许通过。
            *   更新 `TAT = TAT + T` (债务累积，下次要更晚才能调)。
        *   **拒绝**: 如果 `TAT - t > τ` (太早了，超过了容忍上限)，拒绝请求。

### 3.3 GCRA 的优势
*   **Redis 友好**: 只需要在 Redis 中存储 **一个数值** (Key 对应的 TAT 时间戳)，空间复杂度 O(1)。
*   **原子性**: 可以通过一段非常简短的 Lua 脚本完成读取、判断、更新，天然支持分布式并发安全。
*   **高性能**: 无需后台线程（惰性计算），无临界突发问题，且支持突发。

### 3.4 为什么它是“漏桶”的变体但像“令牌桶”？
*   **像漏桶**: 它的计算逻辑基于“间隔”（Emission Interval），保证了长期的平均速率恒定。
*   **像令牌桶**: 它引入了 `τ` (Delay Tolerance)，允许请求堆积“时间额度”。当系统空闲时，`TAT` 不会无限增加，而是重置为当前时间，这意味着空闲后的第一波请求可以利用 `τ` 额度进行突发处理。

### 总结
在 Redis 分布式限流场景下，**GCRA 是目前最优的解决方案**，它结合了固定窗口的低存储成本和令牌桶的灵活突发能力。
