# 修复报告：FailRetry 模式实验断点恢复机制失效


## 1. 缺陷一：历史结果 ID 映射错误

### 1.1 问题描述
在 `GetExptItemTurnResults` 方法中，构建历史结果映射表时，错误地将 `EvaluatorVersionID`（评估器版本ID）作为 Value 赋值，而预期的 Value 应为 `EvaluatorResultID`（评估记录主键ID）。

### 1.2 修复详情
*   **文件**: `backend/modules/evaluation/domain/service/expt_result_impl.go`
*   **方法**: `GetExptItemTurnResults`

**代码对比**:

```go
// Before (Bug)
// 错误：Value 被赋值为 VersionID (如 1001)
turnEvaluatorVerIDToResultID[ref.ExptTurnResultID][ref.EvaluatorVersionID] = ref.EvaluatorVersionID

// After (Fix)
// 正确：Value 被赋值为 ResultID (如 74839201)
turnEvaluatorVerIDToResultID[ref.ExptTurnResultID][ref.EvaluatorVersionID] = ref.EvaluatorResultID
```

### 1.3 修复验证与影响

#### 数据库层面
*   **表名**: `expt_turn_result_run_log`
*   **字段**: `evaluator_result_ids`
*   **修复前**: `{"EvalVerIDToResID":{"1001":1001}}` —— 引用无效，指向不存在的记录 ID。
*   **修复后**: `{"EvalVerIDToResID":{"1001":74839201}}` —— 引用有效，正确指向 `evaluator_record` 表的主键。

> **注**: 虽然如果不修复此问题，重跑 LLM 评测后新生成的数据也会覆盖旧数据，使数据库最终通过“自愈”变得正确；但 **PreEval 阶段的初衷正是为了复用旧数据**。如果此处 ID 错误，Worker 在初始化上下文时调用 `e.evaluatorRecordService.BatchGetEvaluatorRecord` 就无法根据错误的 ID 查找到对应的历史记录，断点恢复机制在第一步就会失效。

---

## 2. 缺陷二：Worker 缓存 Key 不匹配

### 1.1 问题描述
即使 ID 映射正确，Worker 在构建上下文缓存时，使用了 `RecordID` 作为 Map 的 Key，而后续的读取逻辑却使用 `EvaluatorVersionID` 作为 Key 进行查找。这种 **Key Mismatch (键不匹配)** 导致缓存永远无法命中。

### 1.2 修复详情
*   **文件**: `backend/modules/evaluation/domain/service/expt_run_item_impl.go`
*   **方法**: `buildExptTurnEvalCtx`

**代码对比**:

```go
// Before (Bug)
// 错误：使用 RecordID 作为 Key
recordMap[record.ID] = record 

// After (Fix)
// 正确：使用 EvaluatorVersionID 作为 Key，与读取逻辑对齐
recordMap[record.EvaluatorVersionID] = record
```

### 1.3 修复验证 (内存层面)

修复后，Worker 的执行流程如下：

1.  **构建上下文 (`buildExptTurnEvalCtx`)**:
    正确构建了 `etec.ExptTurnRunResult.EvaluatorResults` Map，Key 为 `EvaluatorVersionID`。

2.  **执行评估 (`CallEvaluators`)**:
    在遍历评估器时，能够成功命中缓存并跳过已完成的任务。

    ```go
    // backend/modules/evaluation/domain/service/expt_run_item_turn_impl.go

    func (e *DefaultExptTurnEvaluationImpl) CallEvaluators(ctx context.Context, etec *entity.ExptTurnEvalCtx, targetResult *entity.EvalTargetRecord) (map[int64]*entity.EvaluatorRecord, error) {  
        // ...
        for _, evaluatorVersion := range expt.Evaluators {  
            // 验证点：这里使用 VersionID 查找，现在可以成功取到缓存了
            existResult := etec.ExptTurnRunResult.GetEvaluatorRecord(evaluatorVersion.GetEvaluatorVersionID())  
      
            if existResult != nil && existResult.Status == entity.EvaluatorRunStatusSuccess {  
                // 成功跳过！
                evaluatorResults[existResult.ID] = existResult
                continue  
            }  
            // ...
        }
        // ...
    }
    ```


