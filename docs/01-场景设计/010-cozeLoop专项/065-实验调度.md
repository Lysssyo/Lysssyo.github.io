---
date created: 2026-01-16 15:39:20
date modified: 2026-01-19 16:17:31
---
---
date created: 2026-01-16 16:21:24
date modified: 2026-01-19 16:00:00
---
# CozeLoop 实验调度机制深入解析

本文档详细解析了 CozeLoop 实验平台的核心调度机制，涵盖了从 API 提交、调度器初始化、循环调度、Worker 执行到最终归档的全生命周期流程，并深入探讨了数据库架构设计与状态流转。

---

## 1. 核心架构与设计理念

CozeLoop 的调度系统采用了 **“主表快照 + 流水日志”** 的双层存储架构，结合 **“拉取-分发-回收”** 的调度模型。

*   **调度隔离**: 调度器只扫描 `expt_item_result_run_log` 并严格通过 `ExptRunID` 过滤。这使得针对同一个实验的不同运行批次（Run）可以在互不干扰的情况下并行执行（虽然 API 层有锁，但在架构上支持）。
*   **最后写入者胜 (LWW)**: 主表 (`expt_turn_result`) 总是被最新的 RunLog 覆盖。这保证了用户看到的总是“最近一次尝试”的结果。
*   **增量统计**: 统计表 (`expt_stats`) 的更新是基于状态变迁的差值计算的，确保高并发下的计数准确性。

---

## 2. 全链路流程详解

### 2.1 API 提交阶段

当用户点击“开始实验”或“重试”时，API 层负责校验并触发流程。

1.  **`CreateExpt` (Submit 模式特有)**:
    *   **校验**: 敏感词、余额、数据集有效性、Schema 匹配。
    *   **落库**: 插入 `experiment` (Pending)，关联评估器，预分配 ClickHouse 列映射。

2.  **`RunExperiment`**:
    *   **生成 ID**: 为本次运行生成唯一的 `RunID`。
    *   **抢占分布式锁 (`manager.LogRun`)**:
        *   尝试获取 Redis 锁 `expt_mutex_lock:{ExptID}`。
        *   **关键点**: 如果抢锁失败，直接报错 `ExperimentRunningExistedCode`。这防止了对同一个实验的并发启动操作。
    *   **记录运行日志**: 在 `expt_run_log` 表插入一条记录 (Status: Pending)。
    *   **发送消息**: 向 MQ 发送 `ExptScheduleEvent` {ExptID, RunID, Mode}。

### 2.2 调度器启动阶段 (Scheduler Start)

调度器收到消息后，首先执行初始化逻辑。

*   **入口**: `ExptSubmitExec.ExptStart` (Submit 模式) 或 `ExptFailRetryExec.ExptStart` (Retry 模式)。
*   **Submit 模式初始化**:
    1.  **拉取数据**: 分页调用 `evaluationSetItemService.ListEvaluationSetItems` 拉取数据集。
    2.  **构建对象**: 为每个 Item 创建 `ExptItemResult` 和 `ExptTurnResult` 对象，状态设为 `Queueing`。
    3.  **批量落库 (`BatchCreateNX`)**:
        *   使用 `INSERT IGNORE` 语义批量写入主表 (`expt_item_result`, `expt_turn_result`)。
        *   同时批量写入流水表 (`expt_item_result_run_log`)，状态为 `Queueing`。
    4.  **ClickHouse 全量同步**:
        *   调用 `UpsertExptTurnResultFilter(..., nil)`。
        *   将所有 `Queueing` 状态的记录全量同步到 ClickHouse，用于“占坑”（确保前端显示的总数正确）。
    5.  **更新统计**: 初始化 `expt_stats` 的 `PendingItemCnt`。

### 2.3 循环调度阶段 (Scheduler Loop)

初始化完成后，进入 `ScanEvalItems` -> `Dispatch` -> `Archive` 的无限循环，直到任务全部完成。

#### A. 扫描任务 (`ScanEvalItems`)
调度器扫描 **`expt_item_result_run_log`** 表（注意：不是主表），根据 `ExptRunID` 过滤出三类任务：

1.  **`incomplete` (Processing)**: 正在运行的任务。用于计算当前并发数。
    *   *僵尸检测*: 如果 `UpdatedAt` 超时，视为僵尸任务，标记为 Fail。
2.  **`toSubmit` (Queueing)**: 待分发的任务。
    *   *流控*: `submit_count = max_concurrency - len(incomplete)`。
3.  **`complete` (ResultState=Logged)**: Worker 刚跑完的任务。
    *   这是 Worker 通过回调写入流水表后的中间状态，等待调度器收割。

#### B. 分发任务 (`handleToSubmits`)
针对 `toSubmit` 列表：
1.  **封装事件**: 包装成 `ExptItemEvalEvent`。
2.  **状态更新**:
    *   UPDATE `expt_item_result_run_log` -> `Processing`
    *   UPDATE `expt_item_result` (主表) -> `Processing`
    *   UPDATE `expt_stats` (Queueing--, Processing++)
    *   UPDATE `ClickHouse` -> `Processing`
3.  **发送 MQ**: 发给 Worker 节点执行。

#### C. 收割归档 (`recordEvalItemRunLogs`)
针对 `complete` 列表（`Logged` 状态的任务），执行 **归档 (Archive)** 操作：

1.  **防抖**: `Sleep(1s)` 等待主从同步。
2.  **同步主表 (`RecordItemRunLogs`)**:
    *   读取 Worker 写入的 `expt_turn_result_run_log` (包含 Bot 回答、分数)。
    *   **UPSERT** 到主表 `expt_turn_result` (填充 `TargetResultID`, `EvaluatorResultIDs`)。
    *   **UPDATE** 主表 `expt_item_result` 状态为 `Success/Fail`。
3.  **更新流水**: 将 `expt_item_result_run_log` 的 `ResultState` 更新为 **`Resulted`** (处理完毕)。
4.  **ClickHouse 增量同步**: 将带有最终结果和分数的记录同步到 CK。
5.  **结果推送**: (仅在线模式) 通过 Websocket 推送结果。

### 2.4 Worker 执行阶段 (Worker Execution)

Worker 收到 MQ 消息后：
1.  调用模型 (LLM) 生成回答。
2.  调用评估器 (Evaluator) 打分。
3.  **写入流水**:
    *   INSERT `expt_turn_result_run_log` (记录回答和分数)。
    *   UPDATE `expt_item_result_run_log` (Status=`Success/Fail`, ResultState=`Logged`)。
4.  **注意**: Worker **只写 Log 表，不碰主表**。主表同步完全由调度器负责。

### 2.5 完结阶段 (Finalize Phase)

当调度器发现 `toSubmit == 0` 且 `incomplete == 0` 时，触发结束流程。

*   **入口**: `ExptSubmitExec.ExptEnd` -> `exptBaseExec.exptEnd`。
*   **`CompleteRun`**:
    *   扫描 `expt_turn_result` 计算最终统计 (Success/Fail Cnt)。
    *   更新 `expt_run_log` 状态为 `Success/Failed`。
    *   **释放分布式锁 (`Mutex Unlock`)**: 允许该实验再次运行。
*   **`CompleteExpt`**:
    *   更新 `experiment` 主表状态。
    *   释放 Quota。
    *   触发离线聚合计算 (AggrCalculate)。

---

## 3. 数据库架构与状态机 (DB Schema & State Machine)

### 3.1 数据流转全景图

```text
[ API 层: Create/Run/Retry ]
       |
       +--- (1) INSERT [expt_run_log] (状态: Pending) 
                                                                           
[ 调度器 (Scheduler) - ExptStart 初始化 ]                                  
       |                                                                   
       +--- (2) UPSERT [主表快照] (Status: Queueing)                        
       +--- (3) INSERT [流水日志] (Status: Queueing)                        
       +--- (4) 初始化 [ClickHouse] (Status: Queueing)                      
       |                                                                   
[ 调度器 (Scheduler) - 循环调度周期 ] <--------------------------------------+
       |                                                                   |
       +--- (5) 任务扫描与清理 (Scan & Cleanup) --------------------+        |
       |    |                                                      |        | (NextTick)
       |    +--> [清理僵尸] 检查 Processing 任务是否超时             |        |
       |    |    - 若超时: 强置为 Fail 并转入 "待收割" 队列          |        |
       |    |                                                      |        |
       |    +--> [任务分类] 扫描流水表并按状态归类:                  |        |
       |         - Queueing -> 进入 "待分发" 队列                   |        |
       |         - Logged   -> 进入 "待收割" 队列                   |        |
       |                                                           |        |
       +--- (6) 任务分发 (Dispatch) ----------------------------+   |        |
       |    - UPDATE [流水/主表] -> Processing                  |   |        |
       |    - 更新 [统计表/CK] & 发送 MQ                         |   |        |
       |                                                        |   |        |
       +--- (7) 收割归档 (Archive) <----------------------------+---+        |
       |    - 从 [流水详情] 同步回答/分数至 [主表快照]              |            |
       |    - 更新 [统计表/CK] & UPDATE [流水] -> Resulted       |            |
       |                                                        |            |
[ 执行器 (Worker) ] <-------------------------------------------+            |
       |                                                                    |
       +--- (8) 执行模型推理与评估                                            |
       +--- (9) INSERT [流水详情] (模型回答/评估分)                           |
       +--- (10) UPDATE [流水日志] (Status: Success/Fail, State: Logged) ---+

[ 完结阶段 (Finalize) ]
       |
       +--- (11) UPDATE [experiment] (最终状态: Success/Failed)
       +--- (12) UPDATE [expt_run_log] (归档统计数据 & 释放锁)
```

### 3.2 核心状态机流转

1.  **Init (Start)**: `Queueing` (Log & Result)
2.  **Dispatch**: `Processing` (Log & Result)
3.  **Worker Finish**: `Success/Fail` (Log), `ResultState=Logged` (Log)
    *   *此时 Result 主表仍为 Processing*
4.  **Archive**: `Success/Fail` (Result), `ResultState=Resulted` (Log)
    *   *此时主表完成同步*

---

## 4. 关键组件解析

*   **`ExptSubmitExec` / `ExptFailRetryExec`**:
    *   **角色**: 门面 (Facade) / 策略入口。
    *   **职责**: 负责特定模式的初始化 (`ExptStart`)。例如 Submit 模式从数据集拉数据，Retry 模式从数据库捞失败项。
    *   **实现**: 实现了 `ExptSchedulerMode` 接口。

*   **`exptBaseExec`**:
    *   **角色**: 基础执行器 (Helper)。
    *   **职责**: 封装通用的调度逻辑。
    *   **实现**: `ScanEvalItems` (扫描流水表), `exptEnd` (结束运行、释放锁)。所有模式共享这部分逻辑。