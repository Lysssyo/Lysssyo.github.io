---
date created: 2026-01-28 20:21:42
date modified: 2026-01-28 20:27:32
---
# doc values 详解

Doc Values 可以想象成一个**高度压缩的数组**，或者 Excel 表格中的**一整列**。

### 1. 场景假设

假设我们有 3 个文档，记录了水果的价格：

|**Doc ID**|**Product (Keyword)**|**Price (Integer)**|
|---|---|---|
|0|Apple|10|
|1|Banana|20|
|2|Apple|15|

---

### 2. 倒排索引长什么样？（为了搜索）

**倒排索引**是为了回答：“谁是 Apple？”

它在磁盘上是按**词项 (Term)** 排序存储的：

|**Term**|**Postings List (Doc IDs)**|
|---|---|
|**Apple**|`[0, 2]`|
|**Banana**|`[1]`|

- **痛点**：如果你要算“平均价格”，或者按价格排序，倒排索引就傻眼了。因为它的 Key 是 `Apple`，而不是 `Doc ID`。
    
- **硬算**：你必须遍历整个倒排索引，或者去查原始文档（Source），这会导致大量的随机 I/O，极慢。
    

---

### 3. Doc Values 长什么样？（为了聚合/排序）

**Doc Values** 是为了回答：“Doc 0 的价格是多少？”、“Doc 1 的价格是多少？”

它在磁盘上是把**同一个字段的值，紧凑地排在一起**。

#### A. 数值类型的底层结构

对于 `Price` 字段，Doc Values 在物理上就是一个**紧凑的数组**，数组的索引就是文档 ID（Doc ID）：

```
Doc ID (Implicit):  0   1   2
Price Values:     [10, 20, 15]
```

这就是所谓的**列式存储**。

- **为什么快？**
    
    - **CPU 友好**：数据在内存中是连续的。CPU 预取（Prefetching）非常喜欢这种结构，可以批量把数据加载到缓存行（Cache Line）中。
        
    - **计算极快**：要算平均值？只需在这个数组上跑一个 `for` 循环累加，不需要任何查表跳转。
        

#### B. 字符串类型的底层结构

对于 `Product` 字段，Lucene 不会直接存 `["Apple", "Banana", "Apple"]`，因为字符串太长且不定长。

它采用了 **字典编码 (Dictionary Encoding) + 序号 (Ordinals)** 的策略：

**第一步：提取唯一值并排序（字典表）**

```
0: "Apple"
1: "Banana"
```

**第二步：存储文档对应的序号（Ordinals）**

```
Doc ID:     0  1  2
Ordinals:  [0, 1, 0]
```

**底层真正的样子：**

Lucene 在磁盘上只存了这个 `[0, 1, 0]` 的数字数组。

- **排序**：因为序号本身就是按字典序排好的（0 代表 Apple, 1 代表 Banana），如果我要按 Product 排序，我只需要对这个数字数组排序，完全不需要比较字符串！
    
- **聚合**：如果我要统计“Apple 出现了几次”，我只需要统计数字 `0` 出现了几次。
    

---

### 4. 极致的压缩（Bit Packing & GCD）

你可能会问：“这就完了？就是一个数组？”

当然不。为了省空间，Lucene 会对这个数组进行疯狂压缩。

比如上面的 Price: `[10, 20, 15]`。

如果存储为标准的 64位 long，需要 24 字节。

Lucene 会分析数值特征：

1. **最大公约数 (GCD)**：发现都能被 5 整除。数组变成 `[2, 4, 3]`。
    
2. **Bit Packing**：最大值是 4，只需要 3 个比特（bit）就能存下。
    

**最终物理层：** 它可能不再是字节数组，而是一串紧密的二进制流，每个文档只占几个 bit。这使得数亿行数据的列存储可以轻松放入内存（OS Cache）。

---

### 5. 总结：Doc Values 到底是什么？

|**维度**|**描述**|
|---|---|
|**逻辑上**|`Map<DocID, Value>`，或者是 Excel 里的一整列。|
|**物理上**|一个**连续的**、**经过压缩的**、**数值化**的文件块（.dvd, .dvm 文件）。|
|**内存位置**|它不占用 JVM Heap（堆内存），而是呆在 **OS File System Cache**（堆外内存）里。|
|**优势**|避免了 JVM GC 的压力，且让操作系统负责内存置换。|

如果涉及**实时分析（Dashboard 看板）**，其实就是在大量消耗 Doc Values。如果某些字段不需要聚合/排序（比如很长的备注文本），一定要在 Mapping 中设置 `doc_values: false`，这样能节省大量磁盘空间。

