# 04. 读写链路：数据生命周期与治理

> **摘要**：一个 JSON 文档从被 `POST` 发送那一刻起，经历了分词、缓冲、刷盘、合并等一系列复杂的“变身”。本章我们将追踪一条数据的全生命周期，揭秘 ES 是如何平衡“写入吞吐量”与“搜索实时性”的（NRT 理论），并探讨在高压环境下如何通过水位线（Watermarks）和断路器（Circuit Breakers）防止节点崩溃。

---

## 1. 写入路径 (Write Path)：从 Buffer 到 Disk

写入性能是 ES 的强项，其核心设计哲学借鉴了 **LSM-Tree (Log-Structured Merge-Tree)**。

### 1.1 阶段零：Analysis（文本分析）
在文档进入内存缓冲区之前，必须经过 **Analyzer** 处理。这是倒排索引质量的源头。
*   **流程**：
    1.  **Character Filters**：字符预处理。如 `HTML Strip` 去除 `<div>` 标签，或 `Mapping` 将 ":)" 替换为 "happy"。
    2.  **Tokenizer**：分词。
        *   `Standard`：按空格和标点切分（中文按字切）。
        *   `IK_Max_Word`：中文最细粒度切分（字典匹配）。
    3.  **Token Filters**：后处理。如 `Lowercase`（转小写）、`Stop`（去停用词）、`Synonym`（同义词转换）。
*   **性能影响**：复杂的 Analysis（如正则替换、大量同义词）会显著消耗 CPU，成为写入瓶颈。

### 1.2 阶段一：Buffer 与 Translog
*   **Indexing Buffer**：
    *   文档被解析后，首先写入 JVM Heap 中的 buffer。
    *   **关键状态**：此时数据已存在，但**不可搜索**（因为没生成倒排索引）。
    *   **内存分配**：所有 Shard 共享堆内存的 10%（`indices.memory.index_buffer_size`）。
*   **Translog (Write Ahead Log)**：
    *   为了防止断电数据丢失，原始操作同时被顺序追加到磁盘上的 Translog 文件。
    *   **同步策略**：默认 `request`（每次请求都 fsync）。可调为 `async`（每5秒 fsync）以提升性能，但风险是丢失最近 5 秒数据。

### 1.3 阶段二：Refresh（实现 NRT）
*   **动作**：默认每 1 秒（`index.refresh_interval`），ES 将 Indexing Buffer 中的数据生成一个新的 **Segment**，并写入文件系统缓存（OS Page Cache）。
*   **状态变更**：
    *   Segment 打开供搜索使用 -> **数据变得可见**。
    *   Indexing Buffer 清空。
*   **NRT 理论 (Near Real-Time)**：
    *   ES 选择了“可见性”与“持久性”分离。
    *   Refresh 极快，因为它不强制刷盘（fsync），只写 OS Cache。
    *   这就是为什么你刚写入的数据，可能需要 1 秒后才能搜到。

### 1.4 阶段三：Flush（实现持久化）
*   **触发**：Translog 大小达到 512MB 或时间达到 30分钟。
*   **动作**：
    1.  执行 Lucene Commit：强制将 OS Cache 中的所有 Segments 执行 `fsync` 落盘。
    2.  清空并删除旧的 Translog（因为数据已安全）。
    3.  生成新的 Commit Point 文件。

### 1.5 阶段四：Merge（段合并）
随着 Refresh 不断运行，磁盘上会产生数千个小 Segment。
*   **LSM-Tree 思想**：ES 的写入模型本质上是 LSM-Tree 的变体。利用“追加写”和“不可变段”实现极高的写入吞吐量，代价是读取时需要合并多个段的结果（读放大）。
*   **机制**：后台线程按策略（TieredMergePolicy）自动选择大小相近的段合并。
*   **物理删除**：
    *   在合并前，删除操作只是在 `.del` 文件里打个标记（逻辑删除）。
    *   **只有在 Merge 阶段，被标记的文档才会被真正剔除**。这是释放磁盘空间的唯一时刻。

---

## 2. 读取路径 (Read Path)：Query Then Fetch

搜索是一个两阶段过程，因为数据分布在多个分片上，谁也不知道全局 Top 10 在哪里。

### 2.1 Phase 1: Query (Scatter)
1.  协调节点将搜索请求广播到所有相关分片（主或副）。
2.  **本地执行**：
    *   每个分片在本地倒排索引中查找，并进行打分（Scoring）。
    *   **[Painless 脚本]**：如果使用了 `script_score`，JIT 编译后的脚本会在此阶段对每个匹配文档运行。
3.  **返回轻量结果**：
    *   分片仅返回 Top N 的 `DocID` 和 `Score`，**不返回** `_source` 内容。
    *   这避免了网络传输大量无用数据。

### 2.2 Phase 2: Fetch (Gather)
1.  **全局排序**：协调节点收集所有分片的 Top N（共 $Shards 	imes N$ 条），进行归并排序，选出最终的 Global Top N。
2.  **拉取详情**：协调节点根据 DocID，向持有该文档的分片发送 `Multi-Get` 请求，拉取 `_source` JSON。
3.  **拼装返回**：将结果返回给客户端。

---

## 3. 稳定性治理：资源护城河

在大规模集群中，防止单个恶意查询或数据倾斜搞挂整个节点至关重要。

### 3.1 内存断路器 (Circuit Breakers)
在 Java 语言开发的系统中，**OOM (Out Of Memory)** 是头号杀手。ES 设计了一套精密的熔断机制，在内存爆炸前“自杀式”拒绝请求。

*   **Parent Circuit Breaker**：
    *   **阈值**：JVM Heap 的 95%。
    *   **作用**：总开关。所有子熔断器的内存预估之和不能超过此值。
*   **Request Circuit Breaker**：
    *   **阈值**：JVM Heap 的 60%。
    *   **作用**：防止单个巨大的 Aggregation 或 Query 占满内存。ES 会在执行前计算“预估内存”，如果预估值超限，直接抛出 `429 Too Many Requests`。
*   **Field Data Circuit Breaker**：
    *   **阈值**：JVM Heap 的 40%。
    *   **作用**：防止对 Text 字段进行聚合加载 FieldData 时撑爆内存。

### 3.2 磁盘水位线 (Disk Watermarks) & 自动再平衡
当节点磁盘快满时，ES 会自动介入，防止磁盘写满导致节点宕机。

*   **Low Watermark (85%)**：
    *   一旦节点磁盘使用率超过 85%，集群**不再向该节点分配新的分片**。
*   **High Watermark (90%)**：
    *   一旦超过 90%，集群开始**强制迁移（Relocate）**该节点上现有的分片到其他空闲节点。
*   **Flood Stage Watermark (95%)**：
    *   **最后的防线**。一旦超过 95%，集群强制将该节点上的所有索引设为**只读（read_only_allow_delete）**。
    *   *注意*：即使磁盘清理后，该只读状态通常需要手动 API 解除。

### 3.3 堆外内存 (Off-heap) 战略
为了减轻 GC 压力，ES 极力将数据移出 Heap：
*   **FST**：部分移至 Off-heap。
*   **Doc Values**：完全 mmap，依赖 OS Page Cache。
*   **HNSW Graphs**：倾向于 Off-heap。
> **最佳实践**：不要给 ES 分配超过 32GB 的 Heap（Compressed OOPs 限制）。留给 OS 的内存越多，ES 跑得越快、越稳。

---

## 4. 高级运维策略 (Advanced Ops)

### 4.1 索引生命周期管理 (ILM) 的物理动作
ILM 通过定义 Policy 自动管理数据的冷热流转。
*   **Rollover (滚动)**：当索引达到条件（如 50GB 或 7天）时，自动创建新索引。
    *   *物理意义*：避免产生过大分片（Oversharding），保持分片大小在最佳性能区间（20-50GB）。
*   **Shrink (收缩)**：将主分片数从 N 降为 M（如 5 -> 1）。
    *   *物理意义*：在 Warm 阶段，索引变为只读。减少分片数可大幅降低集群元数据（Cluster State）压力和堆内存占用。
*   **Force Merge (强制合并)**：将 Segment 合并为 1 个。
    *   *物理意义*：彻底物理删除被标记为 `.del` 的文档，释放空间，并将查询时的随机 IO 变为顺序 IO。

### 4.2 零停机迁移 (Zero Downtime Migration)
当需要修改 Mapping（如修改字段类型）时，必须 Reindex。如何不中断业务？

**实战：Alias Swap (别名切换)**
1.  **初始状态**：应用连接别名 `app-logs`，指向 `app-logs-v1`。
2.  **创建新表**：创建 `app-logs-v2`，配置新 Mapping。
3.  **数据迁移**：调用 `_reindex` API 将 v1 数据导数到 v2。
4.  **原子切换**：
    ```json
    POST /_aliases
    {
      "actions": [
        { "remove": { "index": "app-logs-v1", "alias": "app-logs" } },
        { "add":    { "index": "app-logs-v2", "alias": "app-logs" } }
      ]
    }
    ```
5.  **结果**：应用端的读写请求瞬间切换到 v2，全程无感知。
